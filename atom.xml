<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Angelina ZX]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-09-26T10:05:57.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Angelina ZX]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Understanding node process (2)]]></title>
    <link href="http://yoursite.com/2015/09/26/Understanding-node-process-2/"/>
    <id>http://yoursite.com/2015/09/26/Understanding-node-process-2/</id>
    <published>2015-09-26T09:56:26.000Z</published>
    <updated>2015-09-26T10:05:57.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>If you have been broken, mend yourself. Knowing that you will become more beautiful. And always think before you act. an apology cannot repair something you’ve done without thought.</p>
</blockquote>
<p>Last week we talked about multi process and process communication. Today we’re going to take a look at its stability.</p>
<p>Having multi processes work together can improve the usage of our cups at some extend. But how it stability is? What if the process exits unexpected?</p>
<a id="more"></a>
<p>node’s child_process does have some events available here so we can take advantage of those events listener to manage our process.</p>
<h2 id="process_restart">process restart</h2><p>Let’s first listen to its exit event and create a new one when process exits.</p>
<pre><code><span class="comment">// master.js</span>
<span class="keyword">var</span> fork = <span class="built_in">require</span>(<span class="string">"child_process"</span>).fork,
  cpus = <span class="built_in">require</span>(<span class="string">"os"</span>).cpus(),
  server = <span class="built_in">require</span>(<span class="string">"net"</span>).createServer()
  workers = {};

server.listen(<span class="number">1337</span>);

<span class="keyword">var</span> createWorker = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="keyword">var</span> worker = fork(<span class="string">"./test/worker.js"</span>);
  worker.send(<span class="string">"server"</span>, server);
  workers[worker.pid] = worker;
  <span class="built_in">console</span>.log(<span class="string">"create worker. pid: "</span> + worker.pid);

  worker.on(<span class="string">"exit"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="built_in">console</span>.log(<span class="string">"worker "</span> + worker.pid + <span class="string">" exited."</span>);
    <span class="keyword">delete</span> workers[worker.pid];
    createWorker();
  });
};

<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;cpus.length; i++) {
  createWorker();
}

process.on(<span class="string">"exit"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="keyword">for</span> (pid <span class="keyword">in</span> workers) {
    workers[pid].kill();
  }
});
</code></pre><p>The code above defined a createWorker function. Every worker that is created by this function will listen to its own exit event and create a new worker process once it exits. If the master process self exits, all workers will be killed.<br>The worker.js would look like this:</p>
<pre><code><span class="comment">//worker.js</span>
<span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);

<span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span><span class="params">(req,res)</span> </span>{
  res.writeHead(<span class="number">200</span>, {<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>});
  res.end(<span class="string">'handled by child, pid is '</span> + process.pid + <span class="string">'\n'</span>);
});

process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span><span class="params">(m, tcp)</span> </span>{
  <span class="keyword">if</span>(m === <span class="string">'server'</span>) {
    tcp.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span><span class="params">(socket)</span> </span>{
      server.emit(<span class="string">'connection'</span>, socket);
    });
  }
});
</code></pre><p>Run <code>node master.js</code> to create those process.</p>
<pre><code>&gt; node master.js
create worker. <span class="string">pid:</span> <span class="number">1089</span>
create worker. <span class="string">pid:</span> <span class="number">1090</span>
create worker. <span class="string">pid:</span> <span class="number">1091</span>
create worker. <span class="string">pid:</span> <span class="number">1092</span>
</code></pre><p>Now let’s kill a process to see what’s going on.</p>
<pre><code>&gt; <span class="built_in">kill</span> <span class="number">1089</span>
worker <span class="number">1089</span> exited.
<span class="built_in">create</span> worker. pid: <span class="number">1280</span>
</code></pre><p>Aha, one exits, one created.</p>
<p>Here we just killed a process manually. In most cases, there may be some undetected bugs caused unexpected exit. So it’d better to use uncaughtException event to listen uncaught error and do some synchronous cleanup before shutting down the process. Here, for test use, we just exit process to see how it works.</p>
<pre><code><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);

<span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span><span class="params">(req,res)</span> </span>{
  res.writeHead(<span class="number">200</span>, {<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>});
  res.end(<span class="string">'handled by child, pid is '</span> + process.pid + <span class="string">'\n'</span>);
  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"throw exception"</span>);
});

<span class="keyword">var</span> worker;
process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span><span class="params">(m, tcp)</span> </span>{
  <span class="keyword">if</span>(m === <span class="string">'server'</span>) {
    worker = tcp;
    tcp.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span><span class="params">(socket)</span> </span>{
      server.emit(<span class="string">'connection'</span>, socket);
    });
  }
});

process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span><span class="params">(err)</span> </span>{
  process.send({signal: <span class="string">'suicide'</span>}); <span class="comment">//send a suicide signal to master process</span>
  worker.close(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    process.exit();
  });
});
</code></pre><p>To simulate uncaught exception, we throw an error every time there is incomint request so that every time connect to the sever, a process will exit.</p>
<p>Note that we want the master process to recreate a process once error happened instead of waiting for worker process exits to ensure incoming request would be handled as much as possible. This could be done by creating worker in message event.</p>
<pre><code><span class="keyword">var</span> createWorker = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="keyword">var</span> worker = fork(<span class="string">"./test/worker.js"</span>);
  worker.send(<span class="string">"server"</span>, server);
  workers[worker.pid] = worker;
  <span class="built_in">console</span>.log(<span class="string">"create worker. pid: "</span> + worker.pid);

  worker.on(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span><span class="params">(message)</span> </span>{
  <span class="keyword">if</span>(message.signal === <span class="string">'suicide'</span>) {
      createWorker();
  }
  });

  worker.on(<span class="string">"exit"</span>, <span class="function"><span class="keyword">function</span><span class="params">(code, sign)</span> </span>{
  <span class="built_in">console</span>.log(<span class="string">"worker "</span> + worker.pid + <span class="string">" exited."</span>);
  <span class="keyword">delete</span> workers[worker.pid];
  });
};
</code></pre><h2 id="limit_restarts">limit restarts</h2><p>One more thing to do. If the error happens when creating the process, it is not in the case of uncaughtException. That would cause unlimit process restart. To avoid this unlimit restart, it’d better to limit the number of restarts during a period of time.</p>
<pre><code><span class="comment">//master.js</span>
<span class="keyword">var</span> fork = <span class="built_in">require</span>(<span class="string">"child_process"</span>).fork,
  cpus = <span class="built_in">require</span>(<span class="string">"os"</span>).cpus(),
  server = <span class="built_in">require</span>(<span class="string">"net"</span>).createServer()
  workers = {},
  limit = <span class="number">10</span>,<span class="comment">//restart limit</span>
  restart = [];

server.listen(<span class="number">1337</span>);

<span class="keyword">var</span> isTooFrequently = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="keyword">var</span> time = <span class="built_in">Date</span>.now();
  <span class="keyword">var</span> length = restart.push(time);
  <span class="keyword">if</span>(length &gt; limit) {
    restart = restart.slice(limit * -<span class="number">1</span>);
  }
  <span class="keyword">return</span> restart.length &gt;= limit &amp;&amp; restart[restart.length -<span class="number">1</span>] -restart[<span class="number">0</span>] &lt;during;
}

<span class="keyword">var</span> createWorker = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="keyword">if</span>(isTooFrequently()) {
    process.emit(<span class="string">'giveup'</span>, length, during);
    <span class="keyword">return</span>;
  }
  <span class="keyword">var</span> worker = fork(<span class="string">"worker.js"</span>);
  worker.send(<span class="string">"server"</span>, server);
  workers[worker.pid] = worker;
  <span class="built_in">console</span>.log(<span class="string">"create worker. pid: "</span> + worker.pid);

  worker.on(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span><span class="params">(message)</span> </span>{
    <span class="keyword">if</span>(message.signal === <span class="string">'suicide'</span>) {
      createWorker();
    }
  });

  worker.on(<span class="string">"exit"</span>, <span class="function"><span class="keyword">function</span><span class="params">(code, sign)</span> </span>{
    <span class="built_in">console</span>.log(<span class="string">"worker "</span> + worker.pid + <span class="string">" exited."</span>);
    <span class="keyword">delete</span> workers[worker.pid];
  });
};

<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; cpus.length; i++) {
  createWorker();
}

process.on(<span class="string">"exit"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="keyword">for</span> (pid <span class="keyword">in</span> workers) {
    workers[pid].kill();
  }
});
</code></pre><p>This isTooFrequently function does the judgement. It emits giveup event if restarts more than 10 times in a minute.</p>
<h2 id="reference">reference</h2><ul>
<li><a href="https://book.douban.com/subject/25768396/" target="_blank" rel="external">深入浅出nodejs</a></li>
<li><a href="https://nodejs.org/api/process.html#process_signal_events" target="_blank" rel="external">Node.js v4.1.1 Documentation</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>If you have been broken, mend yourself. Knowing that you will become more beautiful. And always think before you act. an apology cannot repair something you’ve done without thought.</p>
</blockquote>
<p>Last week we talked about multi process and process communication. Today we’re going to take a look at its stability.</p>
<p>Having multi processes work together can improve the usage of our cups at some extend. But how it stability is? What if the process exits unexpected?</p>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
      <category term="tech" scheme="http://yoursite.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[understanding node process(1)]]></title>
    <link href="http://yoursite.com/2015/09/19/understanding-node-process-1/"/>
    <id>http://yoursite.com/2015/09/19/understanding-node-process-1/</id>
    <published>2015-09-19T12:52:53.000Z</published>
    <updated>2015-09-19T13:13:21.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>And Lost be the day to us in Which a measure hath not been danced.</p>
<p>And false be every truth which hath not had laughter along with it.</p>
<p>— Niezsche</p>
</blockquote>
<p>As we know, javascript is running on a single process, which brings a question, how can we get the multi-core CPU fully work?</p>
<a id="more"></a>
<h2 id="Multi-process_structure">Multi-process structure</h2><p>Fortunately, node offers us child_process moudle so that we can easily create multi-porcess and work them together.</p>
<p>First of all, we create a js file named parent.js which will create a child process and listen to it.</p>
<pre><code><span class="comment">//parent.js</span>
<span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">'child_process'</span>),
    n = cp.fork(<span class="string">'test/child.js'</span>);

n.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span><span class="params">(m)</span> </span>{
  <span class="built_in">console</span>.log(<span class="string">'parent got message: '</span>, m);
});

n.send({hello: <span class="string">'world'</span>});
</code></pre><p>Note that <code>fork</code> creates a new process whice has all the mehods in a normal ChildProcess with a build-in communication channel(Inter-Process communication channel ). So we can write to a child using <code>send</code> method.</p>
<p>what the child process does is, as same as the parent process’s, listening to the parent process. When there is message come, they print the message out.</p>
<pre><code>process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span><span class="params">(m)</span> </span>{
  <span class="built_in">console</span>.log(<span class="string">'child got meaage: '</span>, m);
});
process.send({foo: <span class="string">'bar'</span>});
</code></pre><p>Running command  <code>node parent.js</code> we can get the following:</p>
<pre><code>child got <span class="string">meaage:</span>  { <span class="string">hello:</span> <span class="string">'world'</span> }
parent got <span class="string">message:</span>  { <span class="string">foo:</span> <span class="string">'bar'</span> }
</code></pre><p>Here we go, now we have two process runing and communicating.</p>
<h2 id="the_handler_delivery">the handler delivery</h2><p>Only text message sent is probably not enough. However, we can also send TCP server or socket object as handler to another process.</p>
<pre><code><span class="comment">//parent.js</span>
<span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">'child_process'</span>),
  child = cp.fork(<span class="string">'test/child.js'</span>);

<span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'net'</span>).createServer();
server.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span><span class="params">(socket)</span> </span>{
  socket.end(<span class="string">'handled by parent\n'</span>);
});

server.listen(<span class="number">1337</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  child.send(<span class="string">'server'</span>, server);
});
</code></pre><p>the child.js would look like this:</p>
<pre><code>process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span><span class="params">(m, server)</span></span> {
  <span class="keyword">if</span>(m === <span class="string">'server'</span>) {
    server.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span><span class="params">(socket)</span></span> {
      socket.<span class="keyword">end</span>(<span class="string">'handled by child\n'</span>);
    });
  }
});
</code></pre><p>Now the server is shared between the parent and child. That means connections can be handled by either of them. Running <code>node parent.js</code> and we test it by <code>curl &quot;http://localhost:1337/&quot;</code> the result can be both.</p>
<p>What if we seperate the tasks of parent process and child process? Once the handle is sent to child process from parent process, we close the server so it no longer listens to the port.</p>
<pre><code><span class="comment">//parent.js</span>
<span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">'child_process'</span>),
    child1 = cp.fork(<span class="string">'test/child.js'</span>),
    child2 = cp.fork(<span class="string">'test/child.js'</span>);

<span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'net'</span>).createServer();

server.listen(<span class="number">1337</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  child1.send(<span class="string">'server'</span>, server);
  child2.send(<span class="string">'server'</span>, server);
  server.close();
});

server.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
  <span class="built_in">console</span>.log(<span class="string">'server closed'</span>);
})
</code></pre><p>change child.js a litte:</p>
<pre><code><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);

<span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span><span class="params">(req,res)</span> </span>{
  res.writeHead(<span class="number">200</span>, {<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>});
  res.end(<span class="string">'handled by child, pid is '</span> + process.pid + <span class="string">'\n'</span>);
});

process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span><span class="params">(m, tcp)</span> </span>{
  <span class="keyword">if</span>(m === <span class="string">'server'</span>) {
    tcp.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span><span class="params">(socket)</span> </span>{
      server.emit(<span class="string">'connection'</span>, socket);
    });
  }
});
</code></pre><p>Now we have two child processes to listen to the port. Once TCP connection is emited, we emit http connection and send client socket object to http server to do something.</p>
<p>Notice that tcp server is shard by more than one child process, It’s possible that the request is handled by differnt child process. But it’s fine. The process  service is preemptive. Depends how busy the process is, the less busy one will handle the request.</p>
<p>Even if node is running on a single process, with multi-process running, we can still better using multi-core CPU and likely to handle high loads situation.</p>
<h3 id="Reference">Reference</h3><ul>
<li><a href="https://nodejs.org/api/child_process.html" target="_blank" rel="external">Node.js v4.1.0 Documentation</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>And Lost be the day to us in Which a measure hath not been danced.</p>
<p>And false be every truth which hath not had laughter along with it.</p>
<p>— Niezsche</p>
</blockquote>
<p>As we know, javascript is running on a single process, which brings a question, how can we get the multi-core CPU fully work?</p>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
      <category term="tech" scheme="http://yoursite.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅谈javascript执行作用域]]></title>
    <link href="http://yoursite.com/2015/08/24/%E6%B5%85%E8%B0%88javascript%E6%89%A7%E8%A1%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2015/08/24/浅谈javascript执行作用域/</id>
    <published>2015-08-24T13:24:25.000Z</published>
    <updated>2015-08-24T15:49:35.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>An old Cherokee told his grandson “my son, there is a battle between 2 wolves inside us all. One is Evil. It is anger, jealousy, greed, resentment, inferiority, lies and ego. The other is Good. It’s joy, kindness, empathy and truth”. The boy thought about it and asked “Gran, which wolf wins?”. The old man quietly replied “The one you feed”.</p>
</blockquote>
<p><br></p>
<p>最近看看javascript基础知识，今天来粗浅的谈谈javascript里函数作用域。</p>
<p>说到函数作用域，就不得不提到闭包。子函数任意访问父函数的变量，并对其长期持有。父函数外部不能访问内部变量。这就是闭包。<br><a id="more"></a></p>
<p>直接上代码：</p>
<pre><code><span class="keyword">var</span> globalVariable = <span class="number">1</span>;
(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="keyword">var</span> localVariable = <span class="number">1</span>;
  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    localVariable += globalVariable;
    <span class="built_in">console</span>.log(localVariable);
  }
})();

add(); <span class="comment">// 2</span>
</code></pre><p>上面的代码结构是这样的：</p>
<pre><code><span class="list">(<span class="keyword">function</span><span class="list">()</span> <span class="collection">{ /* logic goes here */ }</span>)</span><span class="list">()</span><span class="comment">;</span>
</code></pre><p>第一个括号内定义了一个匿名函数（以下叫做一次性匿名函数），第二个括号的作用是立即执行这个函数。上面代码中的this其实是指向外部环境。this上挂载了一个add属性。这个属性的值是一个函数字面量。也就是一次性匿名函数的内部函数。之前提到子函数可以访问父函数变量并长期持有。即使一次性匿名函数执行完后被回收掉，add()仍然是存在的（因为add方法是挂载在全局的）。由于add 长期持有localVariable的引用。我们就可以通过add() 访问localVariable，这就形成了闭包。</p>
<h3 id="实例：">实例：</h3><p>在实际项目里，我就遇到了一个由于变量作用域导致的问题。应用场景大概是这样的：<br>在一个地图上画一个多边形，我有一个对象数组，这个数组里是每一个对象代表地图上多边形的每个折点。现在需要给每一个折点添加dragend事件，鼠标拖动点到新的位置时，更新对象数组中相应点的经纬度位置。起初我是这么做的：(注：以下仅是一段伪代码)</p>
<pre><code>Points = [pt1, pt2, pt3, pt4, pt5]
<span class="comment">//foreach Points as tmpPt, i</span>
<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;Points.length; i++) {
  <span class="keyword">var</span> tmpPt = Points[i];
  tmpPt.addEventListener(<span class="string">'dragend'</span>, <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>{
      Points[i].latlng = e.lat + <span class="string">','</span> + e.lng;
  });
}
</code></pre><p>可是执行的时候，无论我改变哪一个点的位置，Points中点的经纬度都没有变化。这是因为当我给每个点注册了事件后，循环结束，i已经变成了Points.length。dragend触发后程序试图修改Points[Points.length]（其实这个对象根本就不存在）。</p>
<p>这里真正需要的是在回调函数执行时能够取得该点在数组中的索引值。那么就必须把每次循环里的i变成回调函数的内部参数，使其能够长期持有。我的做法是：</p>
<pre><code>tmpPt.addEventListener(<span class="string">'dragend'</span>, (<span class="function"><span class="keyword">function</span><span class="params">(index)</span>{</span>
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(e)</span> {</span>
        Points<span class="matrix">[index]</span>.latlng = e.lat + <span class="string">','</span> + e.lng;
    }
})(<span class="built_in">i</span>)
);
</code></pre><p>注册dragend事件是会立即执行这个一次性匿名函数，把每次循环里的i作为参数传递给一次性执行函数，最后返回一个function (这个返回的function就是回调函数)。此时的i就是一次性匿名函数的内部参数。这里形成了闭包。无论鼠标拖动哪个点，都能够在回调函数中得到正确的索引值。</p>
<p>tips: 学习过程中顺便了解到了函数定义方法 var a = function(){} 和 function a(){} 的区别。 两个函数的调用和功能实现都是一致的。只是function语句（即后者）在解析时会发生被提升的情况。也就是说无论function被放置在哪里，都会被移动到所在作用域的顶层。</p>
<pre><code><span class="built_in">console</span>.log(getA); <span class="comment">// 输出结果： function getA()</span>
<span class="function"><span class="keyword">function</span> <span class="title">getA</span><span class="params">()</span></span>{
    <span class="keyword">return</span> <span class="string">'a'</span>;
}

<span class="built_in">console</span>.log(getB); <span class="comment">// 输出结果： undefined</span>
<span class="keyword">var</span> getB = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">return</span> <span class="string">'B'</span>;
}
</code></pre><p>function getA(){…}在解析时就会被提到作用域顶层。 但是为了不导致混乱，还是建议大家在写代码是先定义再调用。</p>
<h3 id="参考资料">参考资料</h3><ul>
<li><a href="http://blog.csdn.net/pusongyang/article/details/7034904" target="_blank" rel="external">再谈Javascript中function fn(){}和var fn=function(){}</a></li>
<li>javascript语言精粹</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>An old Cherokee told his grandson “my son, there is a battle between 2 wolves inside us all. One is Evil. It is anger, jealousy, greed, resentment, inferiority, lies and ego. The other is Good. It’s joy, kindness, empathy and truth”. The boy thought about it and asked “Gran, which wolf wins?”. The old man quietly replied “The one you feed”.</p>
</blockquote>
<p><br></p>
<p>最近看看javascript基础知识，今天来粗浅的谈谈javascript里函数作用域。</p>
<p>说到函数作用域，就不得不提到闭包。子函数任意访问父函数的变量，并对其长期持有。父函数外部不能访问内部变量。这就是闭包。<br>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="tech" scheme="http://yoursite.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[What we lost?]]></title>
    <link href="http://yoursite.com/2015/08/13/What-we-lost/"/>
    <id>http://yoursite.com/2015/08/13/What-we-lost/</id>
    <published>2015-08-13T14:24:56.000Z</published>
    <updated>2015-08-13T14:31:32.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>In the age of acceleration, nothing can be more exhilarating than going slow. And in the age of distraction, nothing is so luxurious as paying attention. And in the age of constant movement, nothing is so urgent as sitting still.</p>
</blockquote>
<p>Technologe brings our life into a new stage of century. Everything is rising faster and faster. And it means to be used by saving time. But why we still feel lack of time, even more than before? What we lost when we are all rushing into the entire new age?</p>
<a id="more"></a>
<p>In this complete fast going world, we work longer, spending more time on social network instead of being with friends and family in real life. I can’t belive technology is actually cutting off the connection between people. It’s hard to feel the surroundings with all your heart. And certainly, most of us, including me, read people’s life through something called Internet, something called fackbook, wechat comment and other social apps. It, however, is huge waste of time. Because I don’t need to read people’s life but join it.</p>
<p>This is not the first time I feel that my life is going faster than I can be with. We all do. Since last year, while I was rushing into the future, all I heard in my head is noisy, the noisy from outside world. I was the most anxious,emotional painful than I ever felt, which brought me to the hell. I was crying a few times a day. without any reason. Everything that is happening can be the trigger to make me cry. My life was such a mess. I lost the inner peace. I lost the balance between inside and outside. There was nothing I can do to save my life until I went maditating again. What I found out is that the more I was emotional uncomfortable, the more concentrated I can be.</p>
<p>Maditating is slowing me down and preventing me from rushing into the furture. Technologe dose excellent work by improving work efficiency if it’s used correctly. However, it also bring us the side effects of life. What technologe hasn’t always given us is a sense of how to wisest use of technology. In return, it perhaps makes you more tired, confused instead.</p>
<p>This world is much more powerful, infomative. We all go too fast and want to take advantage of it. But on the other hand, it costs more on real personal life.  It’s hard to keep peace inside, that’s also exactly what outside world make us suffer by. Maybe the only way to keep ourselves, our sprits, survive from it is slowing down, feeling things around you with all your heart. The smile of people, the sounds of laughing, the sensation of touching things, and the feeling when you hug people etc.</p>
<p>Meditation ,for me, is not only about sitting down. When you do something with 100% concentration. You are being the present, you are meditating. It’s hard to explain how it changed me. And I’m still trying. But it works. It works well.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>In the age of acceleration, nothing can be more exhilarating than going slow. And in the age of distraction, nothing is so luxurious as paying attention. And in the age of constant movement, nothing is so urgent as sitting still.</p>
</blockquote>
<p>Technologe brings our life into a new stage of century. Everything is rising faster and faster. And it means to be used by saving time. But why we still feel lack of time, even more than before? What we lost when we are all rushing into the entire new age?</p>]]>
    
    </summary>
    
      <category term="life" scheme="http://yoursite.com/tags/life/"/>
    
      <category term="meditation" scheme="http://yoursite.com/tags/meditation/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[gulp学习初体验]]></title>
    <link href="http://yoursite.com/2015/06/21/gulp%E5%AD%A6%E4%B9%A0%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://yoursite.com/2015/06/21/gulp学习初体验/</id>
    <published>2015-06-21T13:02:53.000Z</published>
    <updated>2015-06-21T16:05:37.000Z</updated>
    <content type="html"><![CDATA[<p>花了一天的时间，把gulp的一些基本用法过了一遍。总算对其有了些了解。记录下学习中的不解，也算对这次的学习一个总结。</p>
<p>首先介绍一下gulp，gulp是一个前端构建工具，利用它可以在项目开发过程中自动化执行任务。有赖于其强大的插件系统，我们可以利用gulp完成很多任务，例如执行JSHint，编译stylus，更新版本号等。</p>
<a id="more"></a>
<h2 id="安装gulp：">安装gulp：</h2><p>全局安装：</p>
<pre><code>npm <span class="keyword">install</span> -g gulp
</code></pre><p>项目安装：</p>
<pre><code>npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> gulp
</code></pre><p>—save-dev 安装包将在开发环境下安装，版本信息写入package.json的devDependencies下。</p>
<p>gulp任务都定义在gulpfile.js中，可以在终端运行gulp命令来执行。</p>
<h2 id="gulp任务">gulp任务</h2><p>加载gulp模块</p>
<pre><code><span class="reserved">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);
</code></pre><p>其他gulp插件的加载也是一样。</p>
<p>下面是一段编译stylus的gulp task代码，用来简单解释一下gulp的工作流程。</p>
<pre><code>gulp.task(<span class="string">'stylus'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
  gulp.src(<span class="string">'./assets/stylus/style.styl'</span>)
      .pipe(stylus())
      .pipe(gulp.dest(<span class="string">'./assets/stylesheets'</span>));
});
</code></pre><p>gulp.task(taskName, excutor)用来定义任务。需要任务名和执行函数两个参数。执行函数也可以是多个任务。</p>
<p>gulp.task(‘build’, [‘task’, ‘anotherTask’]);</p>
<p>但是这些任务不是顺序执行的。要保证一个任务先于另一个执行可以：</p>
<pre><code>gulp.task(<span class="string">'taskTwo'</span>, [<span class="string">'taskOne'</span>], <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
   <span class="comment">// taskTwo</span>
});
</code></pre><p>taskTwo 会在 taskOne执行完后再执行。</p>
<p>gulp.src()函数用来匹配文件，创建一个对象流来代表这些文件，之后的操作都是以这些文件为对象进行操作。pipe顾名思义就是管道的意思， stylus()返回修改后的文件对象放入流中，这些输出的文件随着管道被输入到gulp.dest()函数中并保持下来。</p>
<p>最后不要忘记在文件头部加载gulp-stylus模块。</p>
<h2 id="运行gulp">运行gulp</h2><p>终端执行 <code>$ gulp</code> 会报错，因为gulp默认会执行default 任务。需要在gulpfile.js内定义此任务</p>
<pre><code>gulp.task(<span class="string">'default'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
  <span class="comment">//deal with default task</span>
})
</code></pre><p>如果要运行指定任务</p>
<pre><code><span class="variable">$ </span>gulp taskName
</code></pre><h2 id="watching_files">watching files</h2><p>用gulp来监听文件的修改状态非常方便。我们来定义一个watch任务看一下</p>
<pre><code>gulp.task(<span class="string">'watch'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
  gulp.watch(<span class="string">'./assets/stylus/*.styl'</span>, [<span class="string">'stylus'</span>]);
});
</code></pre><p>现在当改变styl文件时就会执行stylus任务。</p>
<p>当然仅仅是watch是不够的，我们还希望在文件修改的同时浏览器能同步更新。browserSync插件就可以做到。当改变代码的时候，BrowserSync会重新加载页面，如果是css文件，会直接添加进css中，页面并不需要再次刷新。这样我们修改前端代码时就不需要每次都手动刷新浏览器。</p>
<pre><code><span class="tag">gulp</span><span class="class">.task</span>(<span class="string">'browser-sync'</span>, <span class="function">function</span>(){
  <span class="tag">browserSync</span><span class="class">.init</span>(null, {
    <span class="attribute">proxy</span>: <span class="string">'http://localhost:3000'</span>,
    <span class="attribute">files</span>: [<span class="string">'assets/stylesheets/*.css'</span>],
    <span class="attribute">browser</span>: <span class="string">'google-chrome'</span>,
    <span class="attribute">port</span>: <span class="number">7000</span>,
    <span class="attribute">reloadOnRestart</span>: false
  });
});
<span class="tag">gulp</span><span class="class">.task</span>(<span class="string">'default'</span>, [<span class="string">'browser-sync'</span>]);
</code></pre><p>gulp运行时会默认执行browser-sync任务。启动browserSync，监听css文件的改变并在chrome中加载更新的部分。</p>
<blockquote>
<p> proxy: vhost url<br> files: 监听改变的文件<br> port: browser侦测改变的端口</p>
</blockquote>
<p>browserSync主要监听浏览器端的改变，要监听更新服务端需要用到nodemon</p>
<pre><code>gulp.task(<span class="string">'nodemon'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
  <span class="keyword">return</span> nodemon({
    script: <span class="string">'bin/www'</span>,
    ext: <span class="string">'js'</span>
  }).on(<span class="string">'start'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{

  });
});
</code></pre><p>项目开发是基于express， 这段代码会执行bin/www文件运行服务端，并监听js文件的改变，每次改变重启服务。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>花了一天的时间，把gulp的一些基本用法过了一遍。总算对其有了些了解。记录下学习中的不解，也算对这次的学习一个总结。</p>
<p>首先介绍一下gulp，gulp是一个前端构建工具，利用它可以在项目开发过程中自动化执行任务。有赖于其强大的插件系统，我们可以利用gulp完成很多任务，例如执行JSHint，编译stylus，更新版本号等。</p>]]>
    
    </summary>
    
      <category term="front-end" scheme="http://yoursite.com/tags/front-end/"/>
    
      <category term="tech" scheme="http://yoursite.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[双线部署遇到的问题]]></title>
    <link href="http://yoursite.com/2015/05/03/%E5%8F%8C%E7%BA%BF%E9%83%A8%E7%BD%B2%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2015/05/03/双线部署遇到的问题/</id>
    <published>2015-05-03T07:23:20.000Z</published>
    <updated>2015-05-09T15:35:26.000Z</updated>
    <content type="html"><![CDATA[<p>本来博客是放在github上面，但是由于国内网络环境（大家懂的），github访问不是很稳定，随时被查水表。所以采取网友的建议，在gitcafe也部署一个。gifcafe是国内的，速度杠杠的～</p>
<a id="more"></a>
<p>这样国内访问走gitcafe，国外访问走github，再做个dnspod双线解析就大功告成。</p>
<p>下面纪录重新双线部署过程中遇到的问题，作学习之用。</p>
<p>hexo部署单个平台没有问题，但是添加一个gitcafe，再deploy就报错了。</p>
<blockquote>
<p>deploy:<br>- type: git<br>  repository: github url<br>  branch: master<br>- type: git<br>  repository: gitcafe url<br>  branch: gitcafe-pages</p>
</blockquote>
<p>github可以正常deploy，gitcafe报错：permission denied。 我想应该是生成的ssh key出了问题。</p>
<p>这里简单说一下ssh key， 为了避免没错连接到github或gitcafe都要输入密码，可以用邮件地址在本地生成id_rsa 和 id_rsa.pub，前者是私钥自己保存，后者是公钥需要添加到github和gitcafe，这样就不用每次连接都输入密码做身份验证了。关于ssh key的生成请戳<a href="https://help.github.com/articles/generating-ssh-keys/" target="_blank" rel="external">这里</a>。</p>
<p>我之前是针对github和gitcafe分别生成了id_rsa,id_rsa.pub和cafe_rsa和cafe_rsa.pub。</p>
<p>但是问题来了，这么多私钥ssh不知道应该用哪一个。其实~/.ssh/id_rsa是基本私钥，ssh总是把它当作提交私钥的首选项。但是如果存在其他的私钥，就需要向ssh提及，好像登记样，并且配置~/.ssh下config文件来指定不同host应该使用的私钥文件。具体看下面：</p>
<pre><code>ssh-<span class="keyword">add</span> ~/.ssh/cafe_rsa
</code></pre><p>检查是否添加成功：</p>
<pre><code>ssh-<span class="keyword">add</span> -l
</code></pre><p>如果是这样就成功了：</p>
<blockquote>
<p>2048 dc:0f:0d:5b:…:a0:0b:a7:d3:62:a6:bc:bc /Users/username/.ssh/id_rsa (RSA)<br>2048 d8:2c:1c:25:…:56:14:c7:79:7e:20:43:20 /Users/username/.ssh/cafe_rsa (RSA)</p>
</blockquote>
<p>config文件的配置：</p>
<blockquote>
<p>Host username.github.com<br>HostName github.com<br>User git<br>IdentityFile ~/.ssh/id_rsa</p>
<p>Host username.gitcafe.com<br>HostName gitcafe.com<br>User git<br>IdentityFile ~/.ssh/cafe_rsa</p>
</blockquote>
<p>同理，如果是一个平台有多个用户，只需要添加相同的项并修改Host的username就行了～</p>
<p>但是我想同时生成那么多key也不是很方便，所以取消了cafe_rsa,直接把id_rsa.pub作为github和gitcafe的ssh key。这样两个平台就公用一个本地私钥。也不用再去设置什么config文件。需要注意的是，生成密钥的邮箱和我github，gitcafe的邮箱是一样的。</p>
<p>再修改一下hexo的_config.yml文件：</p>
<blockquote>
<p>deploy:<br> type: git<br> repository:<br>   github: git@username.github.com:username/username.github.io.git,[branch]<br>   gitcafe: git@username.gitcafe.com:username/username.git,[branch]</p>
</blockquote>
<p>这下就可以同时对两个平台进行部署，尽情发布了～</p>
<h6 id="参考资料">参考资料</h6><ul>
<li><a href="http://wshuyi.github.io/2014/08/22/hexoGithubGitCafe20140822/" target="_blank" rel="external">在github和gitcafe上同时部署hexo博客</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>本来博客是放在github上面，但是由于国内网络环境（大家懂的），github访问不是很稳定，随时被查水表。所以采取网友的建议，在gitcafe也部署一个。gifcafe是国内的，速度杠杠的～</p>]]>
    
    </summary>
    
      <category term="issue" scheme="http://yoursite.com/tags/issue/"/>
    
      <category term="tech" scheme="http://yoursite.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[setup Macbook]]></title>
    <link href="http://yoursite.com/2015/05/02/setup-Macbook/"/>
    <id>http://yoursite.com/2015/05/02/setup-Macbook/</id>
    <published>2015-05-02T15:35:56.000Z</published>
    <updated>2015-05-03T09:11:04.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>工欲善其事，必先利其器</p>
</blockquote>
<p>折腾了两天，终于把新到手的Macbook 各种配置好！ 中间遇到的问题不是一般两般的多，谁叫我是新手呢！！！</p>
<a id="more"></a>
<h2 id="开发">开发</h2><p>最开始的开始，当然是xcode了，很多安装都需要xcode ready first。</p>
<ul>
<li><p>Homebrew： 很好用的包管理工具，后期安装一些应用、插件之类的很方便。</p>
</li>
<li><p>Iterm2 \＋ zsh: 我的最爱，强大的终端。<br><img src="https://iterm2.com/img/screenshots/split_panes_full.png" alt="Iterm2"><br>新手看起来瞬间高大上有木有～</p>
</li>
<li><p>Git： 她的美不言而喻。</p>
</li>
<li><p>Node.js： 有好多东西要学，先抓node。</p>
</li>
<li><p>NPM： Node的包管理系统，安装很方便～</p>
<ul>
<li><p>gulp： npm安装包。</p>
</li>
<li><p>bower： 另一个包管理工具，不要问我为什么那么多包管理工具～</p>
</li>
</ul>
</li>
</ul>
<h2 id="设计">设计</h2><p>Mac怎么能没有设计软件来配成。</p>
<ul>
<li><p>Adobe Photoshop CC</p>
</li>
<li><p>Adobe Lightroom (optional)</p>
</li>
<li><p>Adobe Illustrator (optional)</p>
</li>
<li><p>Sketch (optional)</p>
</li>
</ul>
<h2 id="网络">网络</h2><p>最后当然少不了穿越，你们懂得～</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>工欲善其事，必先利其器</p>
</blockquote>
<p>折腾了两天，终于把新到手的Macbook 各种配置好！ 中间遇到的问题不是一般两般的多，谁叫我是新手呢！！！</p>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://yoursite.com/tags/Mac/"/>
    
      <category term="front-end" scheme="http://yoursite.com/tags/front-end/"/>
    
  </entry>
  
</feed>