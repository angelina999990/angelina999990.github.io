<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Angelina ZX]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2019-04-16T10:34:32.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Angelina ZX]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[浏览器存储]]></title>
    <link href="http://yoursite.com/2019/04/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8/"/>
    <id>http://yoursite.com/2019/04/16/浏览器存储/</id>
    <published>2019-04-16T10:30:53.000Z</published>
    <updated>2019-04-16T10:34:32.000Z</updated>
    <content type="html"><![CDATA[<p>本地存储相关的东西主要涉及到4个，Cookie, localStorage, sessionStorage, indexDB。简单列一张表哥来区分一下他们到分别。</p>
<a id="more"></a>
<table>
<thead>
<tr>
<th style="text-align:left">特性</th>
<th style="text-align:center">Cookie</th>
<th style="text-align:center">localStorage</th>
<th style="text-align:center">sessionStorage</th>
<th style="text-align:center">indexDB </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">管理</td>
<td style="text-align:center">服务端设置，客户端修改和维护</td>
<td style="text-align:center">客户端设置和维护</td>
<td style="text-align:center">客户端设置和维护</td>
<td style="text-align:center">客户端设置和维护</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">生命周期</td>
<td style="text-align:center">可以设置具体的失效日期</td>
<td style="text-align:center">除非手动删除，否则一直有效</td>
<td style="text-align:center">一个会话周期内有效，(关闭tab或浏览器都会导致失效)</td>
<td style="text-align:center">除非手动删除，否则一直有效</td>
</tr>
<tr>
<td style="text-align:left">是否共享</td>
<td style="text-align:center">同源下的多个tab窗口之间可以共享</td>
<td style="text-align:center">同源下的多个tab窗口之间可以共享</td>
<td style="text-align:center">每个tab页面下都是一个新的sessionStorage</td>
<td style="text-align:center">同源下的多个tab窗口之间可以共享</td>
</tr>
<tr>
<td style="text-align:left">接口特性</td>
<td style="text-align:center">同步</td>
<td style="text-align:center">同步</td>
<td style="text-align:center">同步</td>
<td style="text-align:center">异步</td>
</tr>
<tr>
<td style="text-align:left">容量</td>
<td style="text-align:center">4kb</td>
<td style="text-align:center">5MB</td>
<td style="text-align:center">5MB</td>
<td style="text-align:center">&gt; 250MB</td>
</tr>
<tr>
<td style="text-align:left">服务端交互</td>
<td style="text-align:center">每次请求都会最为header带给服务端</td>
<td style="text-align:center">不会随请求发送</td>
<td style="text-align:center">不会随请求发送</td>
<td style="text-align:center">不会随请求发送</td>
</tr>
<tr>
<td style="text-align:left">存储类型</td>
<td style="text-align:center">只能存储字符串类型的值</td>
<td style="text-align:center">只能存储字符串类型的值</td>
<td style="text-align:center">只能存储字符串类型的值</td>
<td style="text-align:center">可以存储各种类型的值</td>
</tr>
</tbody>
</table>
<h2 id="总结">总结</h2><p>Cookie 存储容量小，且可以通过http请求和服务端进行通信，所以cookie更多是用来维持状态，例如标识登录态，服务端拿到cookie解析当前状态再决定如何响应。<br>localStorage和sessionStorage 在功能和接口上大致相同，不同点在于他们的生命周期和作用域，localStorage是持久存储并且支持跨窗口访问，儿sessionStorage则只能被当前窗口访问，且窗口关闭即失效。相对于indexedDB，它们都可以做少量数据的本地存储方案。而indexDB则可考虑用来实现大量结构化数据的存储</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本地存储相关的东西主要涉及到4个，Cookie, localStorage, sessionStorage, indexDB。简单列一张表哥来区分一下他们到分别。</p>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="tech" scheme="http://yoursite.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Chrome devtools 工作原理]]></title>
    <link href="http://yoursite.com/2018/10/27/Chrome-devtools-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/10/27/Chrome-devtools-工作原理/</id>
    <published>2018-10-27T09:00:03.000Z</published>
    <updated>2018-10-27T09:01:33.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>So many books, so little time. - Frank Zappa</p>
</blockquote>
<p>面试的时候被问到Chrome devtools的工作原理没答上来，之后专门学习了一下，写本文梳理下知识点。<br><a id="more"></a></p>
<h2 id="Chrome_远程调试协议（Remote_Debugger_Protocal)">Chrome 远程调试协议（Remote Debugger Protocal)</h2><p>对于Chrome devtools大家普遍熟悉可以通过右键inspector或者cmd+opt+j打开控制台进行本地调试。还有一种方法就是可以通过一个浏览器调试另一个浏览器，或者通过usb连接手机调试手机webView。这两种方式都属于在新启一个窗口远程调试目标页面。这个新启的窗口打开了一个html页面（inspector.html），它的长相与内嵌的devtools一样。在inspector.html调试目标页面就像在内嵌devtools里调试一样。</p>
<h3 id="关于协议">关于协议</h3><p>官方解释是允许工具对Chrome，Chromium及其他基于Blink的浏览器进行调试、审查的协议。它划分了多个不同的功能模块（域），如DOM, Debugger, Network, Timeline等，每个模块以结构化JSON的形式都定义了一些命令和事件。</p>
<h3 id="远程调试原理">远程调试原理</h3><p>前面说了远程调试器页面（inspector.html）能做的事与目标页面内嵌的devtools一样。为什么呢？下面结合实例讲。</p>
<ol>
<li><p>首先新打开一个Chrome作为调试器窗口。</p>
<p>Chrome的远程调试功能默认关闭的，可以通过命令行创建一个chrome实例进行调试</p>
<pre><code>sudo <span class="regexp">/Applications/G</span>oogle\ Chrome.app<span class="regexp">/Contents/M</span>acOS<span class="regexp">/Google\ Chrome --remote-debugging-port=9222</span>
</code></pre><p>这里启动Chrome，Chrome会作为Server host一个web app, 这个web app可以通过<code>http://localhost:9222</code>访问</p>
</li>
<li><p>这时会弹出一个新Chrome窗口，地址栏输入<code>http://localhost:9222</code>能看到一个列表页面，列出了当前所有可调试的页面和插件。要查看这些可调式目标的详细参数也可以通过<code>http://localhost:9222/json</code>。</p>
<p><img src="https://thumbnail0.baidupcs.com/thumbnail/2d228496b8860c23145abb5b26fc676a?fid=571110063-250528-743280518324589&amp;time=1540627200&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-K5B6qgpG7BCo1Jz%2FTYH1yjc%2FUig%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=6950656163287271480&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" alt="Inspectable_Page"></p>
</li>
<li><p>点击Example Page，会导向到<code>http://localhost:9222/devtools/inspector.html?ws=localhost:9222/devtools/page/55A4F84F6A66845F72388146E3B8F986</code>。长得和内嵌devtools一样的html页面。</p>
<p><img src="https://thumbnail0.baidupcs.com/thumbnail/d89f504636bd947233a21cc8cee7882c?fid=571110063-250528-494985038549952&amp;time=1540627200&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-e9tSsi61zmg8q%2FO8W9FkPtyR374%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=6950716047534410240&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" alt="inspector.html"></p>
<p><code>inspector.html</code>和Chrome host之间通过webSocket建立连接，这个websocket地址就是url中ws参数的值。其中<code>55A4F84F6A66845F72388146E3B8F986</code>是page id，每个页面都有一个唯一的page id，chrome就是通过这个id确定哪个是目标页面。页面和chrome 内核之间就是通过这个连接交换数据的。chrome调试器实例和目标页面实例之间是进程通信，所以inspector.html可以通过chrome调试器实例加载目标页面的source文件，还可以操作目标页面，例如加断点、刷新、记录Network信息等。</p>
</li>
</ol>
<h2 id="Devtools_的工作原理">Devtools 的工作原理</h2><p>上面讲的是Remote Debugger Protocal，那当我们在inpector.html上做各种操作时，devtools内部又做了什么的？ 因为inspector.html其实也是一个前端页面，所以我们可以<code>cmd</code> + <code>opt</code> + <code>j</code>调出内嵌的devtools来查看当前这个<code>inpector.html</code>, 以打断点为例来看看devtool都做了那些事：</p>
<ol>
<li><p>首先<code>cmd</code> + <code>opt</code> + <code>j</code>打开内置devtools，切换到Network面板，filter切换到<code>WS</code> tab，刷新页面，找到一条websocket连接。这就是<code>inspector.html</code>与chrome host之间建立的用来交换数据的ws连接。</p>
<p><img src="https://thumbnail0.baidupcs.com/thumbnail/30da67c0cbf574f6ff4a1277351814d1?fid=571110063-250528-313632288517043&amp;time=1540627200&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-2PeNILNSh96HqwcRtFBqNd8sv78%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=6950992930618254344&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" alt="emebed_devtools"></p>
</li>
<li><p>选择<code>Frames</code>可以看到这了ws连接向Chrome host发送了很多条数据，其中一条（上图灰色高亮）<code>{ id: 6, method: &quot;Debugger.enable&quot; }</code>。这一条请求实际上是告诉Chrome去激活当前调试器的Debugger模块，激活之后我们才能够在页面上开始对断点操作（如新增、删除，deactive等)</p>
<p>这一步其实做了很多事情，有兴趣可以去看chrome V8 源码。我没有仔细看，大概就是会编译debugger script文件，里面定义了一些针对js断点操作的函数，如新增、删除、查找、但不调试等</p>
</li>
<li><p>在<code>inspector.html</code>里点击Sources下面的app.js，再来开内嵌devtools里面的ws连接，向Chrome发送了一条请求要求获取scriptId为61的内容，并且chrome响应了这条请求，返回了文件内容，同时展示在页面上。因为chrome在遇到script标签加载完js文件后就会让v8引擎去编译并执行。编译js时会对源码片段进行编号并保存，这样后续就可以通过scriptId找到对应的源码。</p>
<p><img src="https://thumbnail0.baidupcs.com/thumbnail/81761e470117b742e7c6df5055328712?fid=571110063-250528-809651896979711&amp;time=1540627200&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-P55d15Ud9yQXIdhkcW7d63P90yM%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=6950975081609371546&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" alt="getScriptSource"></p>
</li>
<li><p>在app.js某处新增一个断点，再看内嵌devtools，想chrome发送了一条请求setBreakpointByUrl，同时传递参数（params）告知断点设置在哪个位置，设置成功后会返回breakpointId，移除断点时这个这个值会作为<code>Debugger.removeBreakpoint</code>的参数传入告知chrome要移除的断点。</p>
<p><img src="https://thumbnail0.baidupcs.com/thumbnail/7baf8deb8f6062e5b94c78f048983125?fid=571110063-250528-563615321435277&amp;time=1540627200&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-Edz2QVESeDL9uIrLcksDEXeMJGA%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=6950962053385607967&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" alt="setBreakpointByUrl"></p>
</li>
<li><p>在<code>inspector.html</code>设置了断点，这时去目标页面（Example Page）刷新，发现页面执行到断点位置暂停了。这其实是因为我们设置断点时，v8内部将断点回调设置到了C++ Runtime的环境中，javascript的执行实际上被编译成机器码在内部按顺序执行的，执行到某行代码遇到断点就触发回调函数然后程序进入到暂停状态。虽然我们只在<code>inpector.html</code>中设置了断点，但C++ Runtime中的js是同一套，所以刷新Example Page仍然会遇到断点暂停。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>So many books, so little time. - Frank Zappa</p>
</blockquote>
<p>面试的时候被问到Chrome devtools的工作原理没答上来，之后专门学习了一下，写本文梳理下知识点。<br>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="tech" scheme="http://yoursite.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[high performace javascript overview]]></title>
    <link href="http://yoursite.com/2018/10/03/high-performace-javascript-overview/"/>
    <id>http://yoursite.com/2018/10/03/high-performace-javascript-overview/</id>
    <published>2018-10-03T13:13:26.000Z</published>
    <updated>2018-10-03T13:26:32.000Z</updated>
    <content type="html"><![CDATA[<p>最近看完了高性能javascript，粗略的回顾一下各章知识点。由于看到是英文原版，有些翻译成中文的内容可能不太准确，附上原文做参考。<br>因为这本书是2010年写的，很多内容不适合当代浏览器，比如第四章讲到的循环算法Duff’s Device， 实测在chrome浏览器中不适用。还有文末提到的构建工具和性能测试工具，都很旧了，所以谨慎参考。</p>
<a id="more"></a>
<h2 id="Chapter_1:_the_most_optimal_ways_to_load_javascript">Chapter 1: the most optimal ways to load javascript</h2><p>Browsers don’t start rendering on the page until the opening <body> tag is encountered.<br>Every time a <code>&lt;script&gt;</code> tag is encountered, the page must stop and wait for the code to download and execute before continuing to process the rest of the page. UI 渲染和js代码不能同时运行，所以js代码运行时一定会阻塞ui更新。</body></p>
<h3 id="Chapter_1_Summary">Chapter 1 Summary</h3><ul>
<li>尽量把所有<code>&lt;script&gt;</code> 标签放在<code>&lt;/body&gt;</code>前面，让页面在js代码执行前尽可能的渲染</li>
<li>合并js代码，尽量少地加载<code>&lt;script&gt;</code></li>
</ul>
<h2 id="Chapter_2_-_8:_specific_programming_techniques_to_help_js_code_run_faster">Chapter 2 - 8: specific programming techniques to help js code run faster</h2><h2 id="Chapter_2:_Data_Access">Chapter 2: Data Access</h2><p>数据的存放位置会影响到对数据内容的读写速度。此外数据的访问速度还与所处的作用域有关。作用域链从最前面到最末尾分别是：本地作用域（当前执行环境的作用域）、外层执行环境作用域、一次类推最后是全局环境作用域。访问变量越靠近作用域链前端，访问速度越快。</p>
<h3 id="4种数据在代码中的存放">4种数据在代码中的存放</h3><ul>
<li><p>字面值 (literal value): 经代表自身没有被赋值给其他任何东西。如’some string’, 27, true/false, null, undefined, {a: 1, b: 2}, [1,2,3], 匿名函数等等</p>
</li>
<li><p>存在变量中 (variables): 被赋值给变量。如<code>var str = &#39;some string&#39;;</code>, <code>var obj = {a: 1, b: 2}</code>, <code>var arr = [1,3,2]</code></p>
</li>
<li><p>存在数组成员中 (array items): 存放在数组的索引下。 如<code>arr[0], arr[1]</code></p>
</li>
<li><p>存在对象成员中 (object members): 存放在对象属性下。如<code>obj.a, ob[&#39;b&#39;]</code></p>
</li>
</ul>
<h3 id="Chapter_2_Summary">Chapter 2 Summary</h3><ul>
<li><p>相同作用域内访问速度：字面值 &gt; 变量 &gt; 数组成员 &gt; 对象成员。 数组成员以数字作为索引相对会比对象成员访问更快。</p>
</li>
<li><p>数据所处作用域越靠近作用域链前端，访问速度越快</p>
</li>
<li><p>避免使用with，高效实用catch（实用统一的handlerError方法去处理错误，避免在catch内部又过多的数据读写）。</p>
<p>with和try-catch的catch都会加长作用域链（会动态创建一个新的variable object并加到scope chain的最前端）。高效的js擎会只需要通过静态分析就能确定每个变量、函数的作用域，进而确定哪些变量可以在任意时刻被访问。这种作用域也称为静态作用域。可以加速数据的访问。with和catch都是在代码运行时创建作用域，属于动态作用域。无法仅通过静态技术实现，会导致运行时对变量的访问退回到传统访问方式。以下是书中原文：</p>
<blockquote>
<p>Optimizing JavaScript engines such as Safari’s Nitro try to speed up identifier resolution by analyzing the code to determine which variables should be accessible at any given time. These engines try to avoid the traditional scope chain lookup by indexing identifiers for faster resolution. When a dynamic scope is involved, however, this optimization is no longer valid. The engines need to switch back to a slower hash-based approach for identifier resolution that more closely mirrors traditional scope chain lookup</p>
</blockquote>
</li>
<li><p>嵌套对象成员的访问会对性能产生重大影下，应尽可能少的使用</p>
</li>
<li><p>属性、方法在原型链的位置越深，访问越慢</p>
</li>
<li><p>可通过将常用对象、数组、外部变量缓存为局部变量的做法提高访问效率。但是注意最好不要将对象方法存为局部变量，因为对象方法内部可能使用了this关键字，缓存最想方法可能会导致this指向变化。</p>
</li>
</ul>
<h2 id="Chapter_3:_DOM_scripting">Chapter 3: DOM scripting</h2><h3 id="DOM">DOM</h3><p>文档对象模型是一个独立于语言的，对XML和HTML文档进行操作的应用程序接口（API）。DOM API在浏览器中的接口是通过javascript实现的。</p>
<h3 id="为什么操作DOM会带来性能损耗？">为什么操作DOM会带来性能损耗？</h3><blockquote>
<p>Simply having two separate pieces of functionality interfacing with each other will always come at a cost.</p>
</blockquote>
<p>原文中对此有一个比喻，我觉得非常形象：</p>
<blockquote>
<p>An excellent analogy is to think of DOM as a piece of land and JavaScript (meaning ECMAScript) as another piece of land, both connected with a toll bridge. Every time your ECMAScript needs access to the DOM, you have to cross this bridge and pay the performance toll fee. The more you work with the DOM, the more you pay.</p>
</blockquote>
<h3 id="重排和重绘">重排和重绘</h3><p>浏览器并在并解析完所有的文件（html, js, css, 图片资源等），会创建两个内部数据结构：</p>
<ul>
<li><p>DOM 树：表示页面结构，包含所有显示和隐藏的节点（隐藏节点可能是注释、<code>&lt;script&gt;</code>、display为none的元素等）</p>
</li>
<li><p>渲染树：表示页面是如何渲染的，包含所有需要显示在页面的节点<br>树构造完毕开始绘制页面元素</p>
</li>
</ul>
<h4 id="重排">重排</h4><p>DOM元素的几何属性（宽高）发生变化，甚至影响到其他元素的大小和位置。导致浏览器需要重构受影响部分的渲染树，这个过程叫重排。</p>
<h4 id="重绘">重绘</h4><p>重排完成后重新绘制受影响的部分叫重绘。注意几何属性发生变化才会导致重排，backgound color这种变化仅仅导致重绘</p>
<h4 id="导致重排的场景">导致重排的场景</h4><ul>
<li>添加、删除可见元素</li>
<li>元素position变化</li>
<li>元素尺寸变化（width/height/padding/border/margin, etc）</li>
<li>元素内容变化</li>
<li>第一次渲染时</li>
<li>window resize</li>
</ul>
<h4 id="批量修改DOM如何减少重排、重绘">批量修改DOM如何减少重排、重绘</h4><p>原理：先将元素从文档流移除，应用修改，重新插入元素</p>
<ul>
<li><p><strong>使用document fragment，应用修改，插入片段。注意像文档添加document fragment，实际添加的是片段内部的所有子节点群，而不会添加片段本身</strong>。</p>
<p><strong>最推荐这个方法，因为它涉及最少数量的重排和重绘</strong></p>
</li>
<li><p>隐藏元素(display: none)，应用修改， 显示元素（display）</p>
</li>
<li>克隆原始节点、克隆修改、覆盖原始节点</li>
</ul>
<h3 id="Chapter_3_Summary">Chapter 3 Summary</h3><ul>
<li><p>最小化DOM访问，让javascript做尽可能多的事</p>
</li>
<li><p>使用局部变量存储高频访问的dom引用</p>
</li>
<li><p>谨慎处理HTML collections（如document.getElementsByClass的返回值），如someCollection.length会实时返回集合的长度，总是给出最新的值。HTML collections are alive.</p>
</li>
<li><p>使用速度更快的api，如querySelectorAll(), firstElementChild等</p>
</li>
<li><p>浏览器通过队列存放修改内容最后批量修改的方式减少重排次数，但是对布局信息的访问会导致立即重排。尽量减少对布局信息的查询次数</p>
</li>
<li><p>通过绝对定位将必要元素提出文档流，减小渲染树重构面积</p>
</li>
<li><p>使用事件委托</p>
<p>元素与event handler之间的关联也是有代价的（关联元素与event handler占用处理时间和浏览器保存handler记录占用内存）。使用时间委托最小化handler数量</p>
</li>
</ul>
<h2 id="Chapter_4:_Algorithms_and_Flow_Control_（算法和流程控制）">Chapter 4: Algorithms and Flow Control （算法和流程控制）</h2><p>这一章中的一些知识点对于现代浏览器并不适用。比如作者提出的处理大量循环时使用的Duff’s Device算法在现代chrome中并不能提高效率，反而比for循环更慢。 所以本章只对常用技巧进行总结。</p>
<h3 id="Chapter_4_Summary">Chapter 4 Summary</h3><ul>
<li><p>for, while, do-while效率差不多，但是比forEach等方法快。</p>
</li>
<li><p>逆序循环比正序效率更高</p>
</li>
</ul>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="built_in">len</span> = arr.length</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="built_in">len</span></span><br><span class="line">/* 正序 执行步骤</span><br><span class="line">  <span class="number">1.</span> 读取i</span><br><span class="line">  <span class="number">2.</span> 读取<span class="built_in">len</span></span><br><span class="line">  <span class="number">3.</span> 比较(i&lt;<span class="built_in">len</span>)</span><br><span class="line">  <span class="number">4.</span> 判断比较结果（<span class="literal">true</span>/<span class="literal">false</span>)</span><br><span class="line">  <span class="number">5.</span> 如果<span class="literal">true</span>，console.<span class="built_in">log</span></span><br><span class="line">  <span class="number">6.</span> i++, 回到第<span class="number">1</span>步</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="built_in">len</span>) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(arr[i])</span><br><span class="line">  i++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 逆序 执行步骤</span><br><span class="line">  <span class="number">1.</span> 读取j</span><br><span class="line">  <span class="number">2.</span> 判断j是否非<span class="number">0</span></span><br><span class="line">  <span class="number">3.</span> 如果非<span class="number">0</span>，j--</span><br><span class="line">  <span class="number">4.</span> console.<span class="built_in">log</span>, 返回第<span class="number">1</span>步</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">while</span>(j--) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(arr[j])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>除非遍历属性未知的对象，避免使用for-in loop</p>
</li>
<li><p>改善循环效率的方法：减少迭代次数； 减少每次迭代中的运算量</p>
</li>
<li><p>判断条件较多时使用lookup table比if-else或switch更快</p>
</li>
<li><p>浏览器的调用栈（call stack）尺寸会限制递归算法的应用，可使用迭代代替</p>
</li>
<li><p>使用memoization减少重复工作</p>
<p>通过缓存先前计算结果方便后续计算再利用。有效减少重复工作，尤其在递归中。<br>原文解释：</p>
<blockquote>
<p>Memoization is an approach to avoid work repetition by caching previous calculations for later reuse, which makes memoization a useful technique for recursive algorithms.</p>
</blockquote>
<p>两段代码解释Memoization算法：</p>
</li>
</ul>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function factorial(<span class="keyword">n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">n</span> == 0) &#123;</span><br><span class="line">    <span class="keyword">return</span> 1;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">n</span> * factorial(<span class="keyword">n</span>-1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fact6 = factorial(6); <span class="comment">//加上factorial(6)本身，factorial被调用了7次</span></span><br><span class="line"><span class="keyword">var</span> fact5 = factorial(5); <span class="comment">// 调用了6次</span></span><br><span class="line"><span class="keyword">var</span> fact4 = factorial(4); <span class="comment">// 调用了5次</span></span><br></pre></td></tr></table></figure>
<p>改进后<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function factorial(<span class="keyword">n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!factorial.cache) &#123;</span><br><span class="line">    factorial.cache = &#123;</span><br><span class="line">      <span class="string">"0"</span>: 1,</span><br><span class="line">      <span class="string">"1"</span>: 1</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!factorial.cache.hasOwnProperty(<span class="keyword">n</span>)) &#123;</span><br><span class="line">    factorial.cache[<span class="keyword">n</span>] = <span class="keyword">n</span> * factorial (<span class="keyword">n</span>-1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> factorial.cache[<span class="keyword">n</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Chapter_5:_String_and_Regular_Expressions">Chapter 5: String and Regular Expressions</h2><h3 id="Chapter_5_Summary:">Chapter 5 Summary:</h3><ul>
<li><p>计算速度： + 、 += &gt; array.join</p>
</li>
<li><p>正则表达式相关的内容及其匹配原理我觉得是另一个全新的话题了。它的回溯（backtracking）查找使其基本组成部分，也是影响效率的因素。有兴趣的可以去理解一下正则匹配的原理。</p>
</li>
<li><p>关于space trimming，文中内容过于老化（作者提了一些编程方法来修正字符串），不适用如现代javascript。现在js中完全可以用String.prototype.trim实现。</p>
</li>
</ul>
<h2 id="Chapter_6:_Responsive_Interfaces_响应接口">Chapter 6: Responsive Interfaces 响应接口</h2><p>Javscript和用户界面更新在同一个进程下运行，所以js运行时会阻塞页面响应，反之亦然。因此确保javascript不会运行太长时间阻塞用户与页面交互，影响用户体验。</p>
<p>下面这段代码说明js运行对ui的阻塞，<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// html</span></span><br><span class="line">&lt;input id=<span class="string">"textInput"</span> <span class="keyword">class</span>=<span class="string">"custom"</span> size=<span class="string">"32"</span>&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">    Browser Event Loop:</span><br><span class="line">    step1: execute all tasks in stack</span><br><span class="line">    -&gt; step2: execute all micro tasks</span><br><span class="line">    -&gt; step3: render UI</span><br><span class="line">    -&gt; step4: execute first macro task</span><br><span class="line">    -&gt; back to step2 - step4 until no more macro task then start new round of Event Loop</span><br><span class="line"></span><br><span class="line">    Note:</span><br><span class="line">    javasript execution will definitly prevent UI rendering. Cause javascript is single process.</span><br><span class="line">    It can either update UI or execute js one at a time. The way to free up UI rendering is to put js</span><br><span class="line">    code into macro task queue such as use a timer function</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(e)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'gonna sleep'</span>);</span><br><span class="line">  sleep(<span class="number">5000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'awake'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span><span class="params">(duration)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ui won's update until code bellow done execution</span></span><br><span class="line">    <span class="keyword">let</span> time1 = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    <span class="keyword">let</span> time2</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        time2 = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125; <span class="keyword">while</span>(time2 - time1 &lt; duration)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// code bellow won't prevent ui update</span></span><br><span class="line"><span class="comment">//     setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">//         console.log('timer done')</span></span><br><span class="line"><span class="comment">//     &#125;, duration)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.querySelector(<span class="string">'#textInput'</span>)</span><br><span class="line">input.addEventListener(<span class="string">'input'</span>, test)</span><br></pre></td></tr></table></figure>
<p>向input输入‘a’，会执行test，js运行阻塞了ui更新，所以等待5秒后ui才会更新，所以用户输入’a’的头5s是没有看到页面有任何变化的。</p>
<h3 id="Chapter_6_Summary">Chapter 6 Summary</h3><ul>
<li><p>javascript不应该运行超过100ms，过长时间导致ui更新出现可察觉的延迟，影响用户体验。</p>
</li>
<li><p>timer（即定时器，eg. setTimeout）可用于安排代码推迟执行。使得可以将长运行脚本分解成较小任务。</p>
</li>
<li><p>Web Worker允许在ui线程外运行js，避免锁定ui。</p>
</li>
<li><p>用户体验是最重要的，越大型的项目越要有效管理ui线程。</p>
</li>
</ul>
<h2 id="Chapter_7:_Ajax">Chapter 7: Ajax</h2><p>这部分内容我觉得也是比较旧了，总结一些常用的：</p>
<h3 id="Chapter_7_Summary">Chapter 7 Summary</h3><ul>
<li><p>减少请求数量。网络请求都存在网络时延（这句是我自己加的）</p>
</li>
<li><p>友好处理错误，不要直接显示给用户</p>
</li>
</ul>
<h2 id="Chapter_8:_Programming_Practice">Chapter 8: Programming Practice</h2><p>这一章讲了一些通用技巧来优化js性能</p>
<h3 id="Chapter_8_Summary">Chapter 8 Summary</h3><ul>
<li><p>避免使用eval和new Function()避免二次评估，另外给setTimeout和setInterval传递函数作为参数而不是传递字符串。</p>
<p>这四个函数允许传入一串包含代码的字符串作为参数，js运行时会首先将代码当成正常代码执行，然后运行时会发生另一次评估，运行字符串中的代码。二次评估的代价昂贵，会占用更长时间。</p>
</li>
<li><p>创建对象、数组是使用字面量，比使用他们的构造函数初始化更快</p>
</li>
<li><p>避免重复工作，尽量使用延迟加载(lazy loading)或条件加载(conditional loading)</p>
</li>
<li><p>执行数学运算时，考虑使用位运算符，它直接在数字底层进行操作，运算更快</p>
<p>位运算的使用场景</p>
<ol>
<li>常规数学计算<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">100</span>)</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'even'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'odd'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">100</span>)</span><br><span class="line"><span class="keyword">if</span> (i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'odd'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'even'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>位掩码技术（bitmask): 可以同时判断多过选项返回布尔值，或者创建一个数字包含多个选项<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> cat1</span> = <span class="number">1</span> <span class="comment">// 代表 'food' - 二进制 01</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> cat2</span> = <span class="number">2</span> <span class="comment">//'fruit' - 二进制 10</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> cat3</span> = <span class="number">4</span> <span class="comment">//'vegetable' - 二进制 100</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> cat4</span> = <span class="number">8</span> <span class="comment">//'beverage' - 二进制 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对二进制位做或操作，其结果其实和cat1 + cat2相同，只是位运算更快</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> appleIs</span> = cat1 &amp; cat2 <span class="comment">// 二进制码 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 位掩码</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> isAppleFood</span> = appleIs &amp; cat1 <span class="comment">// 11 &amp; 01 --&gt; 01 与cat1的值相等，非零表示为true</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> isAppleFruuit</span> = appleIs &amp; cat2 <span class="comment">// 11 &amp; 10 --&gt; 10 与cat2的值相等</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> isAppleVege</span> = appleIs &amp; cat3 <span class="comment">// 011 &amp; 100 --&gt; 000 即0</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>原生方法运行更快，尽量使用原生方法</p>
</li>
</ul>
<h2 id="Chapter_9:_the_best_to_build_&amp;_deploy_js_files">Chapter 9: the best to build &amp; deploy js files</h2><p>本章介绍了javscript构建和部署过程的基本知识，还给出了一些工具及用法，但过于陈旧不适合不适合现代前端构件流程。只记录一些基本知识。</p>
<h3 id="Chapter_9_Summar">Chapter 9 Summar</h3><ul>
<li>构件流程的基本步骤：<ul>
<li>合并js文件，尽可能减少<code>&lt;script&gt;</code>的使用</li>
<li>压缩文件</li>
<li>以压缩形式（gzip）提供js文件</li>
<li>配置缓存</li>
<li>使用CDN提高性能</li>
</ul>
</li>
</ul>
<h2 id="Chapter_10:_performance_tools_that_help_identify_further_issues">Chapter 10: performance tools that help identify further issues</h2><p>本章介绍了一些javascript的性能测试工具。其中有一些工具已经过时，而且我没有全部研究过上面提到的工具，对于个人使用的性能分析工具有自己的喜好（eg. Chrome Audit），所以这一章略过。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近看完了高性能javascript，粗略的回顾一下各章知识点。由于看到是英文原版，有些翻译成中文的内容可能不太准确，附上原文做参考。<br>因为这本书是2010年写的，很多内容不适合当代浏览器，比如第四章讲到的循环算法Duff’s Device， 实测在chrome浏览器中不适用。还有文末提到的构建工具和性能测试工具，都很旧了，所以谨慎参考。</p>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Javascript 时间时区大杂烩]]></title>
    <link href="http://yoursite.com/2017/10/10/JStimezone/"/>
    <id>http://yoursite.com/2017/10/10/JStimezone/</id>
    <published>2017-10-10T11:25:49.000Z</published>
    <updated>2017-10-10T11:59:44.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>Read not to contridict and confute; nor to believe and take for granted; nor to find talk and discourse; but to weigh and consider.</p>
</blockquote>
<p>以前从来没有认真钻研过JS中Date的时间时区细节，因为工作中遇到了前端页面设置时间，实际保存早／晚了一天的情况，专门花时间学习了相关知识点，谨以此文作学习笔记。</p>
<a id="more"></a>
<h2 id="GMT_&amp;_UTC">GMT &amp; UTC</h2><ul>
<li>GMT (格林威治时间) - 格林尼治标准时间的正午是指当太阳横穿格林威治子午线时（也就是在格林威治上空最高点时）的时间。</li>
<li>UTC (协调世界时) - 是最主要的世界時間標準，其以原子时秒长为基础，在时刻上尽量接近于格林尼治标准时间。</li>
</ul>
<p>以上信息有兴趣可以去维基百科查看详情，看不懂也没关系，只需要记住：两个都是世界标准时间，由于GMT本身存在误差，现在的标准时间由UTC决定。</p>
<h2 id="时间表示法_-_ISO_8601">时间表示法 - ISO 8601</h2><p>国际标准ISO 8601，是国际标准化组织的日期和时间的表示方法。 格式：<code>YYYY-MM-DDThh24:mm:ssZ</code> (eg. <code>2017-08-24T08:45Z</code>)。日期时间合并表示时，要在时间前面加一大写字母T。如果时间是以 UTC 表示，则在时间后面直接加上一个“Z”（不加空格）。“Z”是 UTC 时间中0时区的标志。例如： “09:30 UTC” -&gt; “09:30Z”/“0930Z”。 Date.toJSON 方法返回的就是这种格式的字符串。</p>
<h2 id="Javascript的Date对象">Javascript的Date对象</h2><p>new Date() 返回的是一个本地时间的date对象，</p>
<pre><code><span class="built_in">var</span> <span class="built_in">date</span> <span class="subst">=</span> <span class="literal">new</span> <span class="built_in">Date</span>(); <span class="comment">// Fri Aug 25 2017 13:11:03 GMT+0800 (CST)</span>
<span class="built_in">var</span> dateStr <span class="subst">=</span> <span class="built_in">date</span><span class="built_in">.</span>toISOString(); <span class="comment">// '2017-08-25T05:11:03.000Z'</span>
</code></pre><p>CST（china standard time）是大中华标准时区，我们的时区是在东八区，GMT+0800表示标准时间基础上加8小时。<br>dateStr是date 对象的标准时间表示形式，”Z”表示这是UTC时间，从”05:11:03”也可以看出是在本地时间的基础上减去了8小时。</p>
<pre><code><span class="keyword">var</span> dt1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2017-08-25T05:11:03.000Z'</span>); <span class="comment">// Fri Aug 25 2017 13:11:03 GMT+0800 (CST)</span>

<span class="keyword">var</span> dt2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2017-08-25T05:11:03.000'</span>); <span class="comment">// Fri Aug 25 2017 05:11:03 GMT+0800 (CST)</span>
</code></pre><p>上面两行代码传入的初始时间都是ISO 8601标准，区别在于一个是UTC时间，一个是本地时间（没有”Z”)。如果传入的是UTC时间，那么new Date最后返回的是一个转换为本地时间的date对象，也就是在我们传入的初始日期上+8小时后的日期对象。如果没有”Z”标识，系统默认这是一个本地时间，返回的date对象不再转换。<strong>简而言之，new Date时传入UTC时间，得到+8小时后的时间，传入普通时间字符串，得到时间一致的date对象</strong>。</p>
<p>以下两行代码的效果和上面对应代码具有相同效果：</p>
<pre><code><span class="keyword">var</span> dt1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'Fri Aug 25 2017 05:11:03 UTC'</span>); <span class="comment">// 申明了时区（UTC）， 返回+8小时后的date对像</span>
<span class="keyword">var</span> dt2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'Fri Aug 25 2017 13:11:03'</span>); <span class="comment">// 没有申明时区，返回与传入时间一致的date对象</span>
</code></pre><h2 id="前后端交互">前后端交互</h2><p>经常遇到的一种交互场景： 用户在一个详情页面设置一个带日期时间保存到数据库，下次加载页面的时候显示已有的日期。<br>数据库日期相关的数据类型有多个，有的带时区，有的不带。如果在交互时，前后端对时区的处理不一致，就可能造成最终显示的时间与用户实际选择的时间不一致的情况。举例说明：</p>
<pre><code><span class="comment">// 用户实际选择的时间是： 2017-08-25</span>
<span class="comment">// date object : Fri Aug 25 2017 07:00:00 GMT+0800</span>
<span class="comment">// save data</span>
<span class="variable">$http.put</span>(apiUrl, {time: <span class="string">'2017-08-24T23:00:00.000Z'</span>})<span class="built_in">.</span>then(()<span class="subst">=&gt;</span> <span class="string">'success!'</span>);

<span class="comment">// get page detail</span>
<span class="variable">$http.get</span>(<span class="string">'apiUrl'</span>)<span class="built_in">.</span>then( <span class="built_in">data</span> <span class="subst">=&gt;</span> {
  console<span class="built_in">.</span><span class="keyword">log</span>(<span class="built_in">data</span>);   <span class="comment">// {time: '2017-08-24T23:00:00.000'}</span>
  this<span class="built_in">.</span><span class="built_in">date</span> <span class="subst">=</span> <span class="literal">new</span> <span class="built_in">Date</span>(<span class="built_in">data</span><span class="built_in">.</span>time)<span class="built_in">.</span>toDateString(); <span class="comment">//</span>
});

<span class="comment">//tpl.html</span>
<span class="subst">&lt;</span>p<span class="subst">&gt;</span> <span class="built_in">date</span>: <span class="subst">&lt;!--</span> <span class="subst">%</span><span class="built_in">date</span><span class="subst">%</span> <span class="subst">--&gt;</span>; <span class="subst">&lt;</span>/p<span class="subst">&gt;</span> <span class="comment">// date: Fri Aug 24 2017</span>
</code></pre><p>用户选择一个日期， 我得到一个date对象<code>Fri Aug 25 2017 07:00:00 GMT+0800</code>，转换为JSON数据保存到数据库，实际传给服务端的值是’2017-08-24T23:00:00.000Z’。假设数据库存的是不带时区的时间， 而保存前服务端未对该时间做相应的转换。那页面重新加载时，数据库返回的是一个非UTC时间<code>&#39;2017-08-24T23:00:00.000&#39;</code>。页面显示的就会比用户实际选择的早一天(实际：<code>2017.8.25</code>， 显示：<code>2017.8.24</code>)。</p>
<h4 id="参考">参考</h4><ul>
<li>维基百科</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>Read not to contridict and confute; nor to believe and take for granted; nor to find talk and discourse; but to weigh and consider.</p>
</blockquote>
<p>以前从来没有认真钻研过JS中Date的时间时区细节，因为工作中遇到了前端页面设置时间，实际保存早／晚了一天的情况，专门花时间学习了相关知识点，谨以此文作学习笔记。</p>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[温故而知新 - js事件流机制]]></title>
    <link href="http://yoursite.com/2017/07/12/%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0-js%E4%BA%8B%E4%BB%B6%E6%B5%81%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2017/07/12/温故而知新-js事件流机制/</id>
    <published>2017-07-12T14:57:15.000Z</published>
    <updated>2017-07-13T13:42:21.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>Trying to understand some people is like trying to pick up turd by the clean end.</p>
</blockquote>
<p>事件是javascript一个至关重要的部分，通过派遣／监听事件，可以实现很多动态功能。通过对事件机制的重温，总是能重新刷新一些曾经模糊的知识点。特别写此文给自己加深印象， 如有错误欢迎指正！</p>
<p>以下文章皆以click事件为例：</p>
<h2 id="事件流机制">事件流机制</h2><h3 id="事件传递过程">事件传递过程</h3><p>  事件从 <em>用户行为触发</em> 到 <em>执行完毕</em> 共有三个状态： 捕获（1） - 抵达target元素（2） - 冒泡（3），由事件对象的eventPhase属性标识。看图：</p>
<a id="more"></a>
<p>  <img src="https://www.w3.org/TR/DOM-Level-3-Events/images/eventflow.svg" alt="https://www.w3.org/TR/DOM-Level-3-Events/images/eventflow.svg"></p>
<p>  假设用户点击了一个表格的单元格，按照上图序号表明的顺序， 用户点击鼠标的那一刻开始经历三个过程：</p>
<ul>
<li><p>从最外层的window到最内层的td元素按顺序一一捕获到click事件。此过程event.eventPhase=1。</p>
<p>如果当前元素绑定了要在 <em>捕获阶段执行</em> 的监听函数（listener）, 会在此过程开始执行。 （什么是 <em>捕获阶段执行</em> 的监听函数稍后再说）</p>
</li>
<li><p>事件到达目标元素（可追溯到的最内层元素）。此时event.eventPhase=2。</p>
</li>
<li><p>事件开始向上冒泡。 此时event.eventPhase=3。</p>
<p>如果当前元素绑定了要在 <em>冒泡阶段执行</em> 的监听函数，会在此过程开始执行。</p>
</li>
</ul>
<h3 id="事件对象">事件对象</h3><p>  说明两个概念： 事件对象（event）的两个属性：event.target 和 event.currentTarget。</p>
<ul>
<li><p>event.target 是最终点击到的DOM元素， 在整个事件传递过程中不会变化。</p>
</li>
<li><p>event.currentTarget 是传递过程中，当前遍历到的元素。</p>
<p>`<br>  <table></table></p>
<pre><code><span class="variable">&lt;tbody&gt;</span>
  <span class="variable">&lt;tr&gt;</span>
    <span class="variable">&lt;td&gt;</span> <span class="built_in">table</span> cell <span class="variable">&lt;/td&gt;</span>
  <span class="variable">&lt;/tr&gt;</span>
<span class="variable">&lt;/tbody&gt;</span>
</code></pre><p>  <br>`</p>
<p>如上代码（撇开body及以上的对象）： 点击table cell区域， <code>currentTarget</code>依次是 <code>table &gt; tbody &gt; tr &gt; td(eventPhase=2) &gt; tr &gt; tbody &gt; table</code>，而<code>target</code>一直是<code>td</code></p>
</li>
</ul>
<h2 id="绑定与监听">绑定与监听</h2><p>  举个例子来说明事件的绑定和监听，方便理解上面的概念。</p>
<p>  <img src="https://pcs.baidu.com/rest/2.0/pcs/thumbnail?method=generate&amp;app_id=250528&amp;path=%2Fhexo%20picture%20server%2F20170712.png&amp;quality=90&amp;size=c375_u667" alt="图例2"></p>
<pre><code><span class="comment">//example.html</span>
&lt;div id=<span class="string">"d1"</span>&gt;
  &lt;div id=<span class="string">"d2"</span>&gt;
    &lt;div id=<span class="string">"d3"</span>&gt;
      &lt;div id=<span class="string">"d4"</span>&gt;&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;

<span class="comment">// style.css</span>
#d1 {
  <span class="variable">width</span>: <span class="number">200</span>px;
  <span class="variable">height</span>: <span class="number">200</span>px;
  <span class="built_in">background</span>: aliceblue;
  margin: auto;
  <span class="built_in">text</span>-align: center;
}
#d2 {
  <span class="variable">width</span>: <span class="number">150</span>px;
  <span class="variable">height</span>: <span class="number">150</span>px;
  <span class="built_in">background</span>: antiquewhite;
}
#d3 {
  <span class="variable">height</span>: <span class="number">100</span>px;
  <span class="variable">width</span>: <span class="number">100</span>px;
  <span class="built_in">background</span>: beige;
}
#d4 {
  <span class="variable">width</span>: <span class="number">50</span>px;
  <span class="variable">height</span>: <span class="number">50</span>px;
  <span class="built_in">background</span>: azure;
}

<span class="comment">//example.js</span>
<span class="keyword">for</span>(let elem of document.querySelectorAll(<span class="string">"#d1, #d1 *"</span>)) {
  elem.addEventListener(<span class="string">"click"</span>, e =&gt; console.<span class="built_in">log</span>(`Capturing: ${elem.id}`), <span class="keyword">true</span>);
  elem.addEventListener(<span class="string">"click"</span>, e =&gt; console.<span class="built_in">log</span>(`Bubbling: ${elem.id}`));
}

<span class="comment">//output （点击d4区域）</span>
Capturing: d1
Capturing: d2
Capturing: d3
Capturing: d4
Bubbling: d4
Bubbling: d3
Bubbling: d2
Bubbling: d1
</code></pre><h3 id="绑定事件">绑定事件</h3><p>  有些js库封装了自己都事件绑定函数，这里不赘述，本质都是基于js原生都addEventListener方法。</p>
<p>  addEventListener接收3个函数，前两个分别是事件类型和监听函数，不必多说。 注意第三个参数： 可以是Object / Boolean.</p>
<ul>
<li><p>Boolean</p>
<p>true - 表示指定都监听函数将在事件 <em>捕获阶段</em> 执行<br>false(Default) - 表示监听函数在事件 <em>冒泡阶段</em> 执行</p>
<p>这个值直接影响到不同元素对同一事件响应的作出先后顺序</p>
</li>
<li><p>Object</p>
<pre><code>{
  <span class="attribute">capture</span>: Boolean,
  <span class="attribute">once</span>: Boolean,
  <span class="attribute">passive</span>: Boolean
}
</code></pre><p>这种形式不是本文的重点，详情可参考<a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="external">这里</a>！</p>
</li>
</ul>
<h3 id="target">target</h3><p>  在整个事件传递过程中，</p>
<p>  如果用户点击d4区域：</p>
<ul>
<li>currentTarget 的变化： <code>d1</code> &gt; <code>d2</code> &gt; <code>d3</code> &gt; <code>d4</code> &gt; <code>d4</code> &gt; <code>d3</code> &gt; <code>d2</code> &gt; <code>d1</code>。</li>
<li><p>target： <code>d4</code></p>
<p>如果用户点击d2中不覆盖d3,d4的区域：</p>
</li>
<li><p>currentTarget 的变化： <code>d1</code> &gt; <code>d2</code> &gt; <code>d2</code> &gt; <code>d1</code>。</p>
</li>
<li>target： <code>d2</code></li>
</ul>
<p>  也就是说： event.target的值取决于事件触发时可追溯到的最内层元素。 点击d2中不覆盖d3,d4的区域，d2就是当前点击事件的最内层元素，所以event.target指向d2。</p>
<h2 id="细枝末节">细枝末节</h2><p>event对象有两个方法 <code>preventDefault</code> 和 <code>stopPropergation</code>:</p>
<ul>
<li><p>event.preventDefault() - 取消事件的默认行为；</p>
</li>
<li><p>event.stopPropergation() - 阻止事件继续传递；</p>
</li>
</ul>
<p>其中， <code>preventDefault</code>是取消事件的默认行为，但并不会阻止事件的传递，会继续 捕获 -&gt; 抵到 -&gt; 冒泡 的过程。 如下例：</p>
<pre><code>&lt;input id=<span class="string">"checkbox"</span> type=<span class="string">'checkbox'</span> value=<span class="keyword">true</span> /&gt;

<span class="comment">// js</span>
<span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'checkbox'</span>);
el.addEventListener(‘click’， e =&gt; e.preventDefault());
</code></pre><p>点击这个checkbox的时候，正常情况checkbox应该被勾上， 但调用了<code>preventDefault()</code>方法，取消了该DOM元素点击事件的默认行为，checkbox就不会再勾选上。</p>
<p><code>stopPropergation</code>是阻止事件继续往后传递。例如，</p>
<pre><code>&lt;input id=<span class="string">"checkbox"</span> type=<span class="string">'checkbox'</span> value=<span class="keyword">true</span> /&gt;

<span class="comment">// js</span>
<span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'checkbox'</span>);
el.addEventListener(<span class="string">'click'</span>， e =&gt; e.stopPropergation(), <span class="keyword">true</span>);
el.addEventListener(<span class="string">'click'</span>， e =&gt; console.log(el.tagName), <span class="keyword">true</span>);
</code></pre><p>点击这个checkbox，由于在 <em>捕获阶段</em> 调用了<code>stopPropergation()</code>, 在此被截断，阻止了事件继续向后传递，根本不会有后面冒泡的过程，所以最后根本不会输出元素标签。通常元素的默认点击行为是在事件冒泡阶段才执行，所以这里虽然点击了checkbox，但仍然不会勾选上。</p>
<h2 id="总结">总结</h2><ul>
<li><p>事件传递的三个状态： 捕获(1)、抵达目标(2)、冒泡(3)，由事件对象Event的eventPhase属性标识；</p>
</li>
<li><p>Event.target始终指向事件触发时可追溯到的最深层元素；Event.currentTarget指事件传递过程中当前遍历到的元素；</p>
</li>
<li><p>Event.preventDefault() 取消事件的默认行为，但不会阻止传递； Event.stopPropergation()阻止事件继续向后传递；</p>
</li>
</ul>
<h6 id="参考资料">参考资料</h6><ul>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="external">EventTarget.addEventListener() - MDN</a></p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Event/eventPhase" target="_blank" rel="external">Event.eventPhase - MDN</a></p>
</li>
<li><p><a href="https://www.w3.org/TR/DOM-Level-3-Events/#event-flow" target="_blank" rel="external">DOM Event Architecture</a></p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>Trying to understand some people is like trying to pick up turd by the clean end.</p>
</blockquote>
<p>事件是javascript一个至关重要的部分，通过派遣／监听事件，可以实现很多动态功能。通过对事件机制的重温，总是能重新刷新一些曾经模糊的知识点。特别写此文给自己加深印象， 如有错误欢迎指正！</p>
<p>以下文章皆以click事件为例：</p>
<h2 id="事件流机制">事件流机制</h2><h3 id="事件传递过程">事件传递过程</h3><p>  事件从 <em>用户行为触发</em> 到 <em>执行完毕</em> 共有三个状态： 捕获（1） - 抵达target元素（2） - 冒泡（3），由事件对象的eventPhase属性标识。看图：</p>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="tech" scheme="http://yoursite.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅谈javascript中的原型和继承]]></title>
    <link href="http://yoursite.com/2017/02/16/%E6%B5%85%E8%B0%88javascript%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF/"/>
    <id>http://yoursite.com/2017/02/16/浅谈javascript中的原型和继承/</id>
    <published>2017-02-16T07:20:51.000Z</published>
    <updated>2017-02-16T08:58:00.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>How to travel in time? read. How to feel time? Write.</p>
</blockquote>
<p>前几天仔细的看了看javascript的原型模式和基于原型的继承， 今天就对其作一个简单的总结作为读书笔记。</p>
<h2 id="什么是原型">什么是原型</h2><p>说原型之前，我们先来说说函数吧。<br><a id="more"></a></p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">()</span> </span>{
}

Person.prototype.name = <span class="string">'Scofiled'</span>;
Person.prototype.age = <span class="number">29</span>;
Person.prottype.sayName = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
 <span class="keyword">return</span> <span class="keyword">this</span>.name;
}

<span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();
person1.sayName(); <span class="comment">// 'Scofield'</span>
alert(person1.age); <span class="comment">//29</span>

<span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();
person2.sayName(); <span class="comment">// 'Scofield'</span>
alert(person2.age); <span class="comment">//29</span>
</code></pre><p>这里定义了一个名为<code>Person</code>的函数，然后在在它的<code>prototype</code>属性上又添加了如上几个属性。 然后创建了<code>Person</code>的两个实例。<br>这个<code>prototype</code> 是哪里来的呢？ <strong>我们每创建一个新函数， 就会自动为该函数创建一个<code>prototype</code>属性，这个属性指向一个对象，这个对象就是原型对象</strong>。<br>原型对象是拿来干嘛的？如上面代码显示的，<code>person1</code> 和<code>person2</code>都是<code>Person</code>的实例， 这两个实例都具有了<code>Person.prototype</code>上定义的属性和方法。简而言之，<strong>原型对象的用途就是让某特定类型（如：<code>Person</code>）的所有实例（如：<code>person1</code>和<code>person2</code>）能共享一些属性和方法</strong>。</p>
<p>需要注意的是，这里的name,age和sayName()都是原型对象上的属性和方法，并非实例本身所有。在调用构造函数（<code>Person</code>）创建实例（<code>person1</code>和<code>person2</code>）后，实例内部将包含一个指针指向构造函数的原型对象（<code>Person.prototype</code>）。 举个列子，读取<code>person1.age</code>时<code>person1</code>本身是没有age这个属性的, 但是程序会在读取属性时执行一次搜索，从实例本身开始，找到目标则停止，否则继续向上查找原型对象。所以<code>person1.age</code>的值其实是在查找原型对象时返回的。</p>
<h2 id="原型链和继承">原型链和继承</h2><p>说完原型，就来说继承。 继承的实现主要是通过原型链。 上面大概理了一下原型和实例的关系， <code>person1</code>的指针是指向原型对象<code>Person.prototype</code>的，<code>Person.prototype</code>是在定义<code>Person</code>时自动创建并有我们手动添加了一些属性和方法。试想一下，如果Person.prototype指向的是另一个类型的实例会怎样。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">superPerson</span><span class="params">()</span> </span>{
  <span class="keyword">this</span>.superProperty = <span class="string">'super'</span>;
}

SuperPerson.prototype.superName = <span class="string">'protoSuper'</span>;
SuperPerson.prototype.getSuperName = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="keyword">return</span> <span class="keyword">this</span>.superName;
}

<span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">()</span> </span>{
  <span class="keyword">this</span>.personProperty = <span class="string">'person'</span>;
}

Person.prototype = <span class="keyword">new</span> SuperPerson(); <span class="comment">// {superProperty: 'super'}</span>

<span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(); <span class="comment">// {personProperty: 'person'}</span>

person1.getSuperName(); <span class="comment">// 'protoSuper'</span>
alert(person1.superProperty); <span class="comment">// 'super'</span>
alert(person1.personProperty); <span class="comment">// 'person'</span>
</code></pre><p>如上，定义了一个<code>SuperPerson</code>类型。在定义Person后我们首先创建一个<code>SuperPerson</code>实例并将其赋值给<code>Person.prototype</code>。上面讲原型时提到过，在调用构造函数创建实例后，实例内部将包含一个指针指向构造函数的原型对象，所以这里 <code>new SuperPerson()</code> 得到的实例对象内部也包含一个指针指向<code>SuperPerson</code>的原型对象（即<code>SuperPerson.prototype</code>），当然也会继承<code>SuperPerson.prototype</code>上包含的属性和方法。</p>
<p>在读取 <code>person1.getSuperName</code> 方法时执行了3次搜索，第1次<code>person1</code>本身，没有找到目标； 第2次便根据<code>person1</code>内部指针指向的原型对象（Person.prototype）去查找，也没有找到；第3次根据<code>Person.prototype</code>内部指针指向的原型（<code>SuperPerson.prototype</code>）查找，找到目标。</p>
<p>在读取 <code>person1.superProperty</code>时执行了两次查找，第1次仍然是没有找到，第2次查找<code>Person.prototype</code>时，由于<code>Person.prototype</code>是<code>SuperPerson</code>的一个实例，所以<code>Person.prototype</code>是具有<code>superProperty</code>属性的。所以成功在<code>Person</code>的原型对象上找到。</p>
<p>同样的<code>person1</code>是<code>Person</code>的实例，所以<code>person1</code>本身是具有<code>personProperty</code>这个属性的。所以读取<code>person1.personProperty</code>时只执行了一次搜索。</p>
<p>如上面这种一个原型又是另一个类型的实例，这样层层递进，就构成了实力与原型的链条，就是作为的<strong>原型链</strong>。仿造着这种方法，我们还可以根据需要给这条原型链的头尾继续增加其他类型，来实现属性和方法的继承。</p>
<p>这里只是简单的说了说原型和继承的概念，其中当然还涉及了更为复杂的问题，还是留着下一次再细说吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>How to travel in time? read. How to feel time? Write.</p>
</blockquote>
<p>前几天仔细的看了看javascript的原型模式和基于原型的继承， 今天就对其作一个简单的总结作为读书笔记。</p>
<h2 id="什么是原型">什么是原型</h2><p>说原型之前，我们先来说说函数吧。<br>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="tech" scheme="http://yoursite.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[理解javascript this关键字的在不同情况下的表现]]></title>
    <link href="http://yoursite.com/2016/08/25/understanding-javascript-this/"/>
    <id>http://yoursite.com/2016/08/25/understanding-javascript-this/</id>
    <published>2016-08-25T03:26:26.000Z</published>
    <updated>2016-08-25T03:32:24.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>The best time for new beginnings is now</p>
</blockquote>
<p>this的指向问题在javascript中一直比较困扰我。 一下总结了几种情况下this分别指向的内容。 总的来说就是根据执行环境或函数的执行方式不同，this的值有所不同。<br>这里假设执行环境是在浏览器端，所有的全局对象都是指window对象</p>
<a id="more"></a>
<h2 id="定义在全局模式下">定义在全局模式下</h2><pre><code>{
    <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="regexp">//</span><span class="literal">true</span>; 未定义任何函数的情况下，<span class="keyword">this</span> 指向<span class="built_in">window</span>
}
</code></pre><h2 id="定义在函数内部">定义在函数内部</h2><p>根据函数的调用方式不同，this的值可能不同</p>
<h3 id="普通调用">普通调用</h3><pre><code>{
    a = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }

    b = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
<span class="pi">        "use strict"</span>
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }

    a(); <span class="comment">// 非严格模式： this指向全局对象</span>
    b(); <span class="comment">// 严格模式： this = undefine;</span>
}
</code></pre><h3 id="对象内部调用">对象内部调用</h3><p>需要注意的是this的指向总是与他最近的执行环境相关。 看下面的列子：</p>
<pre><code>{
    o = {
        a: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
            <span class="keyword">return</span> <span class="keyword">this</span>;
        },

        b: {
            c: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
                <span class="keyword">return</span> <span class="keyword">this</span>;
            }
        }
    };

    o.a(); <span class="comment">//作为对象的方法被调用， this指向调用该方法的对象本身，即o</span>

    o.b.c(); <span class="comment">// c是作为o.b这个对象的方法被调用的，所以c返回的this是指向o.b这个对象的</span>


    <span class="comment">//再看下面的例子</span>

    d = o.b.c;
    d(); <span class="comment">// d是在全局环境下调用的，所以返回的this是指向window对象的</span>
}
</code></pre><p>但是如果是arrow function 定义的函数， 其this会被绑定到该函数外层执行环境的this上， 看下面的例子：</p>
<pre><code>{
    x = <span class="number">10</span>;
    o2 = {

        <span class="attribute">x</span>: <span class="keyword">this</span>.x, <span class="regexp">//</span> 此时的<span class="keyword">this</span>是指向<span class="built_in">window</span>对象的

        <span class="attribute">e</span>: <span class="function"><span class="params">( () =&gt; <span class="keyword">this</span>)</span>,

        f: function<span class="params">()</span> {
            var g = (<span class="params">()</span> =&gt;</span> {
                <span class="built_in">console</span>.log(<span class="keyword">this</span>.e());
                <span class="keyword">return</span> <span class="keyword">this</span>;
            });
            <span class="keyword">return</span> g();
        }
    };

    o2.e(); <span class="regexp">//</span><span class="built_in">window</span>
    o2.f(); <span class="regexp">//</span>Object{}
}
</code></pre><p>执行o2.e()返回window对象。因为e的外层是o2, o2的this指向Global，所以e() 返回的this 是window对象。</p>
<p>o2.f 内部又定义了g 函数。该函数验证了两件事：</p>
<ol>
<li>g 本身的this指向；</li>
<li>不同环境下调用e(), 其this返回值会不会变化；</li>
</ol>
<p>因为g的外层是f函数，f的this是指向o2对象本身的。所以g()返回的this是o2对象本身。也正是因为如此，如果 <code>console.log(this.e())</code> 才能够成功调用e(), 如果this不是执行o2, 那么 <code>console.log(this.e())</code> 就会报 <code>Uncaught TypeError: this.e is not a function(…)</code>。 另外this.e()的返回结果仍然是window对象，这就说明了arrow function 的另一个特性，arrow function 的this在创建的时候就指定了(即其外层执行环境的this上)。当然如果可以指定其外层执行环境，那就另当别论了。</p>
<pre><code><span class="collection">{
    // 这里修改一下o2.f
    o2.f = function<span class="list">()</span> <span class="collection">{
        var g = <span class="list">(<span class="list">()</span> =&gt; <span class="collection">{
            return this;
        }</span>)</span><span class="comment">;</span>
        return g<span class="list">()</span><span class="comment">;</span>
    }</span><span class="comment">;</span>

    o3 = <span class="collection">{}</span><span class="comment">;</span>

    o2.f.apply<span class="list">(<span class="keyword">o3</span>)</span><span class="comment">;</span>
}</span>
</code></pre><p>这里通过apply 调用o2.f, 使of.f的this指向o3, 这样一来g()返回的this就指向了o3 本身。 去掉 <code>console.log(this.e());</code>这行代码的原因就是为了避免报<code>Uncaught TypeError: this.e is not a function(…)</code>错误（因为o3上没有定义e这个函数）;</p>
<h3 id="通过new调用">通过new调用</h3><p>通过new调用的函数作为一个构造函数被执行去创建一个特定的实例对象。它主要做了3件事:</p>
<ol>
<li>创建一个新对象，继承其构造函数的原型链；</li>
<li>执行该构造函数并把this绑定到新创建的对象上；</li>
<li><p>如果构造函数有返回对象则将刚返回对象作为new表达式的执行结果（），如果未返回对象，则将第一步创建的对象作为最终结果。</p>
<p> {</p>
<pre><code><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span><span class="params">(a, b)</span> </span>{
    <span class="keyword">this</span>.name = a || <span class="string">""</span>;
    <span class="keyword">this</span>.age = b || <span class="string">""</span>;
};

<span class="keyword">var</span> AnotherPerson = <span class="function"><span class="keyword">function</span><span class="params">(a,b)</span> </span>{
    <span class="keyword">this</span>.name = a || <span class="string">""</span>;
    <span class="keyword">this</span>.age = b || <span class="string">""</span>;
    <span class="keyword">return</span> {name: <span class="string">"Simpson"</span>};
};

p1 = <span class="keyword">new</span> Person(<span class="string">"Jane"</span>, <span class="number">22</span>); <span class="comment">// {name: "Jane", age: "22"};</span>
p2 = <span class="keyword">new</span> AnotherPerson(<span class="string">"Jane"</span>, <span class="number">22</span>); <span class="comment">// {name: "Simpson"};</span>
</code></pre><p> }</p>
</li>
</ol>
<p>像上面的例子，this始终是指向第一步创建的对象，当构造函数没有返回对象时，p1得到的结果即是第一步创建的对象被赋值后的结果。 当构造函数具有返回对象时， <code>this.name = a || &quot;&quot;; this.age = b || &quot;&quot;;</code>其实也执行了，第一步创建的对象其实也被赋值了，只是最终结果被其返回值覆盖了。</p>
<h3 id="通过call,_apply调用">通过call, apply调用</h3><p>前面的例子已经提到过，通过apply可以指定function内部的this指向一个特定的对象，通过call方法也是一样的，只需将特定的对象作为参数传递进去，函数内部的this就会指定到这个特定的对象上。</p>
<pre><code>{

    <span class="keyword">var</span> k = 1;

    function <span class="literal">j</span>() {
        <span class="keyword">return</span> this.k;
    }

    <span class="keyword">var</span> <span class="keyword">l</span> = {
        k: 10
    };

    <span class="literal">j</span>(); <span class="comment">// 1;  this指向window对象</span>
    j.apply(<span class="keyword">l</span>); <span class="comment">//10</span>
    j.call(<span class="keyword">l</span>); <span class="comment">//10</span>
}
</code></pre><h3 id="通过bind指定对象调用函数">通过bind指定对象调用函数</h3><p>bind和call,apply的作用类似，也是将function内部的this绑定到一个特定的对象上。</p>
<pre><code>{

    <span class="keyword">var</span> k = 1;
    function <span class="literal">j</span>() {
        <span class="keyword">return</span> this.k;
    }

    <span class="keyword">var</span> <span class="keyword">l</span> = {
        k: 10
    };

    <span class="keyword">m</span> = j.bind(<span class="keyword">l</span>);

    <span class="literal">j</span>(); <span class="comment">// 1</span>
    <span class="literal">m</span>(); <span class="comment">// 10</span>
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>The best time for new beginnings is now</p>
</blockquote>
<p>this的指向问题在javascript中一直比较困扰我。 一下总结了几种情况下this分别指向的内容。 总的来说就是根据执行环境或函数的执行方式不同，this的值有所不同。<br>这里假设执行环境是在浏览器端，所有的全局对象都是指window对象</p>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="tech" scheme="http://yoursite.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[understanding express(2)之expressJS接收和处理http请求过程]]></title>
    <link href="http://yoursite.com/2016/01/28/understanding-express-2/"/>
    <id>http://yoursite.com/2016/01/28/understanding-express-2/</id>
    <published>2016-01-27T16:08:16.000Z</published>
    <updated>2016-01-28T02:28:56.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>Have the courage to follow your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary</p>
</blockquote>
<p>今天来了解整个接收和处理请求的过程。</p>
<p><a href="http://angelina999990.gitcafe.io/2016/01/25/understanding-expressJS/" target="_blank" rel="external">上一章</a>说了当接收到一个请求的时候是通过这个函数 <code>app.handle(req, res, next);</code> 来处理请求的。今天来说一下具体一个请求的处理过程。</p>
<p>收到请求会执行<code>app.handle(req, res, next)</code>，具体代码如下：</p>
<a id="more"></a>
<pre><code><span class="comment">//application.js</span>
app.handle = <span class="function"><span class="keyword">function</span><span class="params">(req, res, done)</span> </span>{
  <span class="keyword">var</span> router = <span class="keyword">this</span>._router;

  <span class="comment">// final handler</span>
  done = done || finalhandler(req, res, {
    env: <span class="keyword">this</span>.<span class="keyword">get</span>(<span class="string">'env'</span>),
    onerror: logerror.bind(<span class="keyword">this</span>)
  });

  <span class="comment">// no routes</span>
  <span class="keyword">if</span> (!router) {
    debug(<span class="string">'no routes defined on app'</span>);
    done();
    <span class="keyword">return</span>;
  }

  router.handle(req, res, done);
};
</code></pre><p>这个函数接收三个参数req，res，next。 其中next就是上面的done, 默认是finalhandler。具体可以看<a href="https://github.com/pillarjs/finalhandler" target="_blank" rel="external">这里</a>。然后调用router.handle()开始链式调用。</p>
<p>router.handler 代码比较长，先看结构：</p>
<pre><code><span class="comment">// router/index.js</span>
proto.handle = <span class="function"><span class="keyword">function</span><span class="params">(req, res, done)</span> </span>{
  ...... <span class="comment">//定义一些基本变量</span>

  next();

  <span class="function"><span class="keyword">function</span> <span class="title">next</span><span class="params">(err)</span> </span>{
    ......
  }

  <span class="function"><span class="keyword">function</span> <span class="title">trim_prefix</span><span class="params">(layer, layerError, layerPath, path)</span> </span>{
    ...... <span class="comment">//对路径做些处理再调用layer.handle_request</span>
  }
};
</code></pre><p>其中通过递归调用next()来遍历stack(存放中间件的栈，是一个数组)看是否有匹配的中间件。在proto.handle的开头就定义了idx=0，表示当前中间件索引。在next()中首先判断当前中间件索引是否大于stack.length。 如果是说明已遍历完，直接执行done()。</p>
<pre><code>// <span class="keyword">function</span> next()
<span class="keyword">if</span> (idx &gt;= stack.length) {
  <span class="built_in">set</span>Immediate(<span class="keyword">done</span>, layerError);
  <span class="built_in">return</span>;
}
</code></pre><p>否则的话执行while循环找到第一个可以处理http请求的中间件。 来看一下while的主要代码：</p>
<pre><code>// function next()
<span class="keyword">var</span> layer;
<span class="keyword">var</span> match;
<span class="keyword">var</span> route;

<span class="keyword">while</span> (match !== <span class="literal">true</span> &amp;&amp; idx &lt; stack.length) {
  layer = stack[idx++];
  match = matchLayer(layer, path);  //调用了layer.match 方法
  route = layer.route;

  <span class="keyword">if</span> (typeof match !== 'boolean') {
    layerError = layerError || match;
  }

  <span class="keyword">if</span> (match !== <span class="literal">true</span>) {
    <span class="keyword">continue</span>; // 不匹配，退出本次循环。
  }

  <span class="keyword">if</span> (!route) {
    <span class="keyword">continue</span>;
  }

  <span class="keyword">if</span> (layerError) {
    match = <span class="literal">false</span>;
    <span class="keyword">continue</span>;
  }

  <span class="keyword">var</span> <span class="keyword">method</span> = req.<span class="keyword">method</span>;
  <span class="keyword">var</span> has_method = route._handles_method(<span class="keyword">method</span>);

  <span class="keyword">if</span> (!has_method &amp;&amp; <span class="keyword">method</span> === '<span class="type">OPTIONS</span>') {
    appendMethods(options, route._options());
  }

  <span class="keyword">if</span> (!has_method &amp;&amp; <span class="keyword">method</span> !== '<span class="type">HEAD</span>') {
    match = <span class="literal">false</span>;
    <span class="keyword">continue</span>;
  }
}
</code></pre><p>通过matchLayer确定当前layer是否与当前路径匹配。不匹配则直接结束本次循环进入下一个中间件的判断。match为true但是layer.route不存在，说明不是路由中间件，结束本次循环，由于此时match为true会结束while循环直接进入下面的步骤（这个稍后说）。 如果route存在，即是路由中间件，再判断该路由可处理的http方法是否与请求的http方法一致。如果不一致则根据其method是否为options或head做相应处理，一致则不再对match做修改，这样执行下次while循环的时候由于match为true会结束循环进入下面的步骤。</p>
<pre><code>// <span class="function"><span class="keyword">function</span> <span class="title">next</span><span class="params">()</span></span> 结束<span class="keyword">while</span>循环后的部分

<span class="keyword">if</span> (match !== <span class="keyword">true</span>) {
   //结束循环后match仍然为<span class="keyword">false</span>, 说明是遍历完stack, 没有匹配的中间件
  <span class="keyword">return</span> done(layerError);
}

<span class="keyword">if</span> (route) {
  req.route = route;
}

req.params = self.mergeParams
  ? mergeParams(layer.params, parentParams)
  : layer.params;
var layerPath = layer.path;

self.process_params(layer, paramcalled, req, res, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span></span> {
  <span class="keyword">if</span> (err) {
    <span class="keyword">return</span> <span class="built_in">next</span>(layerError || err);
  }

  <span class="keyword">if</span> (route) {
    //<span class="built_in">next</span>作为回调函数传入handle_request,形成一个闭包，再在handle_request中调用<span class="built_in">next</span>()的时候idx的值仍然是上一次退出<span class="keyword">while</span>循环的值
    <span class="keyword">return</span> layer.handle_request(req, res, <span class="built_in">next</span>);
  }

  //对路径做些处理再调用layer.handle_request
  trim_prefix(layer, layerError, layerPath, path);
});
</code></pre><p>这部分首先进行一些参数预处理，如果为路由中间件就直接调用layer.handle_request，否则先对路径做些处理再调用layer.handle_request。下面是layer.handle_request的代码：</p>
<pre><code><span class="comment">// router/layer.js</span>
Layer.prototype.handle_request = <span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">(req, res, next)</span> </span>{
  <span class="keyword">var</span> fn = <span class="keyword">this</span>.handle;

  <span class="keyword">if</span> (fn.length &gt; <span class="number">3</span>) {
    <span class="comment">// not a standard request handler</span>
    <span class="keyword">return</span> next();
  }

  <span class="keyword">try</span> {
    fn(req, res, next);
  } <span class="keyword">catch</span> (err) {
    next(err);
  }
};
</code></pre><p>layer.handle_request会在Router.handle和route.dispatch中调用。注意若是从Router.handle调用的，next是Router.handle里定义的next，若是从route.dispatch调用的，next是dispatch里定义的next。 不同的next遍历的对象有所不同。举个🌰：</p>
<pre><code><span class="comment">//app.js</span>
    <span class="keyword">var</span> user = <span class="keyword">require</span>(<span class="string">'user'</span>);
    <span class="keyword">var</span> app = express();

    app.<span class="keyword">use</span>(<span class="string">'/index'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="comment">//do something</span>
    })
    app.<span class="keyword">use</span>(<span class="string">'/user'</span>, user);


<span class="comment">//user.js</span>
    <span class="keyword">var</span> userRouter = <span class="keyword">require</span>(<span class="string">'express'</span>).Router();
    <span class="keyword">var</span> checkAuth = <span class="function"><span class="keyword">function</span><span class="params">(req, res, next)</span></span>{
        <span class="comment">//... check auth</span>
        next()
    };
    <span class="keyword">var</span> getList = <span class="function"><span class="keyword">function</span><span class="params">(req, res, next)</span> </span>{
        <span class="comment">//... get user list</span>
    }

    userRouter.get(<span class="string">'/list'</span>, checkAuth, getList);
    module.exports = userRouter;
</code></pre><p>app.js中的两个app.use其实是调用router.use创建了两个layer对象并将其添加到app._router.stack中，以下简称Router。Router.stack应该是类似这样的<code>[ layer1, layer2 ]</code>。 其中layer2实际上是express.Router()的导出对象, 在app.use方法中会视为一个子app封装一层。像这样：</p>
<pre><code><span class="comment">//application.js app.use()</span>
<span class="function"><span class="keyword">function</span> <span class="title">mounted_app</span><span class="params">(req, res, next)</span> </span>{
  <span class="keyword">var</span> orig = req.app;
  fn.handle(req, res, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>{
    req.__proto__ = orig.request;
    res.__proto__ = orig.response;
    next(err);
});
</code></pre><p>这里的fn实际上就是<code>app.use(&#39;/user&#39;,user)</code>中的user（即user.js中导出的Router）。完整代码可查看application.js 的app.use。</p>
<p>上面user.js中调用userRouter.get方法创建一个新的route和layer（这里暂时叫newLayer, 这个layer会被push到userRouter.stack中）， 再调用route.get方法把checkAuth和getList添加到route.stack中，所以该route的stack应该类似这样 <code>[ layer3, layer4 ]</code>，userRouter.stack是这样的<code>[ newLayer ]</code>。 这里附上Router.route和 Router.VERB的代码。</p>
<pre><code>// router/index.js
proto.route = function(path){
  <span class="keyword">var</span> route = new <span class="type">Route</span>(path);

  <span class="keyword">var</span> layer = new <span class="type">Layer</span>(path, {
    sensitive: this.caseSensitive,
    strict: this.strict,
    <span class="keyword">end</span>: <span class="literal">true</span>
  }, route.dispatch.<span class="keyword">bind</span>(route)); //layer.handle=route.dispatch

  layer.route = route;

  this.stack.push(layer);
  <span class="keyword">return</span> route;
};

// 创建 <span class="type">Router</span><span class="comment">#VERB functions</span>
methods.concat('all').forEach(function(<span class="keyword">method</span>){
  proto[<span class="keyword">method</span>] = function(path){

    // 调用proto.route new 一个route对象。
    <span class="keyword">var</span> route = this.route(path)

    //在route.<span class="type">VERB</span>或route.all中会把传入的fn添加到该route的stack中
    route[<span class="keyword">method</span>].apply(route, slice.call(arguments, <span class="number">1</span>));
    <span class="keyword">return</span> this;
  };
});
</code></pre><p>所以当收到一个http请求(eg. <a href="http://host.com/user/list)，" target="_blank" rel="external">http://host.com/user/list)，</a> 首先执行app.handle(), 在 <code>[layer1, layer2]</code>中查找匹配，当查找的layer2的时候，路径匹配且layer2不是一个路由中间件，进入到layer.handle_request调用layer.handle(这里的layer.handle就是mounted_app方法),里面又调用fn.handle就是执行userRouter.handle方法，又继续在userRouter.stack（<code>[ newLayer ]</code>）中查找匹配, newLayer路径与请求路径匹配且是路由中间件，进入layer.handle_request执行layer.handle，注意这里的layer.handle是route.dispatch，因为在Router.VERB中创建layer时是<code>new Layer(path, option, route.dispatch.bind(route))</code>。所以就会在route.stack(<code>[ layer3, layer4 ]</code>)中查找匹配。附上route.dispatch代码：</p>
<pre><code><span class="type">Route</span>.prototype.dispatch = function(req, res, done){
  <span class="keyword">var</span> idx = <span class="number">0</span>;
  <span class="keyword">var</span> stack = this.stack;
  <span class="keyword">if</span> (stack.length === <span class="number">0</span>) {
    <span class="keyword">return</span> done();
  }

  <span class="keyword">var</span> <span class="keyword">method</span> = req.<span class="keyword">method</span>.toLowerCase();
  <span class="keyword">if</span> (<span class="keyword">method</span> === 'head' &amp;&amp; !this.methods['head']) {
    <span class="keyword">method</span> = 'get';
  }

  req.route = this;

  next();

  function next(err) {
    <span class="keyword">if</span> (err &amp;&amp; err === 'route') {
      <span class="keyword">return</span> done();
    }

    <span class="keyword">var</span> layer = stack[idx++];
    <span class="keyword">if</span> (!layer) {
      <span class="keyword">return</span> done(err);
    }

    <span class="keyword">if</span> (layer.<span class="keyword">method</span> &amp;&amp; layer.<span class="keyword">method</span> !== <span class="keyword">method</span>) {
      <span class="keyword">return</span> next(err);
    }

    <span class="keyword">if</span> (err) {
      layer.handle_error(err, req, res, next);
    } <span class="keyword">else</span> {
      layer.handle_request(req, res, next);
    }
  }
};
</code></pre><p>可以看到这里的idx是0，与Router.handle()中的idx不同，route.dispatch是在当前route.stack中遍历匹配。在上面的🌰中route.stack就是<code>[ layer3, layer4 ]</code>。处理逻辑与Router.handle类似，idx是当前下表，stack是当前路由处理函数列表，递归调用next。 这里next方法判断当前layer是否存在，不存在或方法不匹配调用done, 否则根据err值执行handle_request或handle_error。例子中的layer3路径和method都匹配，执行layer3.handle_request调用this.handle即checkauth方法，如果通过验证就会执行next(),注意这时的next是dispatch中定义的next方法。此时idx指向layer4, 依然匹配，继续执行getList方法。 getList执行后若不再调用next(), 则处理请求的过程结束， 否则继续执行next, 此时route.stack遍历完再找不到layer会执行done(err) 返回到<code>[newLayer]</code>层面，userRouter.stack也遍历完（userRouter.handle中的idx此时为1，大于<code>[newLayer].length</code>）于是又调用done, 回到上层的Router.stack中(<code>[layer1, layer2]</code>)依次类推。当热由于getList处理完请求后直接reponse所以不会再调用next()。 这里只是分析下如果继续调用next的行为。</p>
<p>表述得可能不太清楚，看图：</p>
<p><img src="http://d.pcs.baidu.com/thumbnail/c9ddf27e2239ce53983f5628faab78de?fid=571110063-250528-341365159016922&amp;time=1453910400&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-89IEUyBrNLkIrRrkm0IX4DReUj4%3D&amp;rt=sh&amp;expires=2h&amp;r=914482467&amp;sharesign=unknown&amp;size=c710_u500&amp;quality=100" alt="http请求处理过程"></p>
<h3 id="Reference">Reference</h3><ul>
<li><a href="https://github.com/syaning/understanding-express" target="_blank" rel="external">express源码解析</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>Have the courage to follow your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary</p>
</blockquote>
<p>今天来了解整个接收和处理请求的过程。</p>
<p><a href="http://angelina999990.gitcafe.io/2016/01/25/understanding-expressJS/">上一章</a>说了当接收到一个请求的时候是通过这个函数 <code>app.handle(req, res, next);</code> 来处理请求的。今天来说一下具体一个请求的处理过程。</p>
<p>收到请求会执行<code>app.handle(req, res, next)</code>，具体代码如下：</p>]]>
    
    </summary>
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[understanding expressJS (1)]]></title>
    <link href="http://yoursite.com/2016/01/25/understanding-expressJS/"/>
    <id>http://yoursite.com/2016/01/25/understanding-expressJS/</id>
    <published>2016-01-25T12:39:34.000Z</published>
    <updated>2016-01-27T16:10:18.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>Working like don’t need money, dancing like no one’s watching, love like never get hurt</p>
</blockquote>
<p>这里主要了解一下启动一个express 应用的过程</p>
<pre><code><span class="comment">//express.js</span>
function createApplication() {
  <span class="keyword">var</span> <span class="keyword">app</span> = function(req, res, next) {
    <span class="keyword">app</span>.handle(req, res, next);
  };

  mixin(<span class="keyword">app</span>, EventEmitter.prototype, false);
  mixin(<span class="keyword">app</span>, proto, false);

  <span class="keyword">app</span>.request = { __proto__: req, <span class="keyword">app</span>: <span class="keyword">app</span> };
  <span class="keyword">app</span>.response = { __proto__: res, <span class="keyword">app</span>: <span class="keyword">app</span> };
  <span class="keyword">app</span>.init();
  <span class="keyword">return</span> <span class="keyword">app</span>;
}
</code></pre><a id="more"></a>
<p>express.js 实际上定义导出了一个createApplication的函数。express()实际上是得到了一个app的实例。</p>
<pre><code><span class="keyword">mixin</span>(app, proto, <span class="literal">false</span>);
</code></pre><p>这段代码的作用就是把application.js下定义的属性扩展到app上。</p>
<pre><code><span class="comment">// bin/www</span>
<span class="variable"><span class="keyword">var</span> server</span> = http.createServer(app);
</code></pre><p>http.createServer 接受一个函数作为request事件的回调函数。实际下面这种写法也是一样的。</p>
<pre><code>var <span class="keyword">server</span> = http.createServer();
<span class="keyword">server</span>.on(<span class="string">'request'</span>, app);
</code></pre><p>这里传到createServer的app就是上面得到的app实例（实际就是一个函数）。在接收到http请求时会执行app.handle 方法。app.handle 方法定义如下：</p>
<pre><code><span class="comment">//application.js</span>
app.handle = <span class="function"><span class="keyword">function</span><span class="params">(req, res, done)</span> </span>{
  <span class="keyword">var</span> router = <span class="keyword">this</span>._router;

  <span class="comment">// final handler</span>
  done = done || finalhandler(req, res, {
    env: <span class="keyword">this</span>.<span class="keyword">get</span>(<span class="string">'env'</span>),
    onerror: logerror.bind(<span class="keyword">this</span>)
  });

  <span class="comment">// no routes</span>
  <span class="keyword">if</span> (!router) {
    debug(<span class="string">'no routes defined on app'</span>);
    done();
    <span class="keyword">return</span>;
  }

  router.handle(req, res, done);
};
</code></pre><p>this._router(即app._router)实际上是在app.lazyrouter方法中new的一个Router对象, 一般在定义中间件的时候会用到这个方法来给app添加一个_router属性。 所以上面的app.handle 其实是router.handle的一个代理方法，最终还是调用的router.handle()。至于具体处理请求的过程另写一遍具体介绍。</p>
<p>回到www/bin文件</p>
<pre><code>var <span class="keyword">port</span> = normalizePort(<span class="keyword">process</span>.env.<span class="keyword">PORT</span> || '<span class="number">3001</span>');
app.set(<span class="attribute">'port</span>', <span class="keyword">port</span>);

var server = http.createServer(app);

server.listen(<span class="keyword">port</span>);
server.<span class="keyword">on</span>(<span class="attribute">'error</span>', onError);
server.<span class="keyword">on</span>(<span class="attribute">'listening</span>', onListening);
</code></pre><p>这里首先增加port属性到app.js。 然后创建一个http server 并监听它的request, err, listening时间。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>Working like don’t need money, dancing like no one’s watching, love like never get hurt</p>
</blockquote>
<p>这里主要了解一下启动一个express 应用的过程</p>
<pre><code><span class="comment">//express.js</span>
function createApplication() {
  <span class="keyword">var</span> <span class="keyword">app</span> = function(req, res, next) {
    <span class="keyword">app</span>.handle(req, res, next);
  };

  mixin(<span class="keyword">app</span>, EventEmitter.prototype, false);
  mixin(<span class="keyword">app</span>, proto, false);

  <span class="keyword">app</span>.request = { __proto__: req, <span class="keyword">app</span>: <span class="keyword">app</span> };
  <span class="keyword">app</span>.response = { __proto__: res, <span class="keyword">app</span>: <span class="keyword">app</span> };
  <span class="keyword">app</span>.init();
  <span class="keyword">return</span> <span class="keyword">app</span>;
}
</code></pre>]]>
    
    </summary>
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Understanding node process (2)]]></title>
    <link href="http://yoursite.com/2015/09/26/Understanding-node-process-2/"/>
    <id>http://yoursite.com/2015/09/26/Understanding-node-process-2/</id>
    <published>2015-09-26T09:56:26.000Z</published>
    <updated>2015-09-26T10:05:57.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>If you have been broken, mend yourself. Knowing that you will become more beautiful. And always think before you act. an apology cannot repair something you’ve done without thought.</p>
</blockquote>
<p>Last week we talked about multi process and process communication. Today we’re going to take a look at its stability.</p>
<p>Having multi processes work together can improve the usage of our cups at some extend. But how it stability is? What if the process exits unexpected?</p>
<a id="more"></a>
<p>node’s child_process does have some events available here so we can take advantage of those events listener to manage our process.</p>
<h2 id="process_restart">process restart</h2><p>Let’s first listen to its exit event and create a new one when process exits.</p>
<pre><code><span class="comment">// master.js</span>
<span class="keyword">var</span> fork = <span class="built_in">require</span>(<span class="string">"child_process"</span>).fork,
  cpus = <span class="built_in">require</span>(<span class="string">"os"</span>).cpus(),
  server = <span class="built_in">require</span>(<span class="string">"net"</span>).createServer()
  workers = {};

server.listen(<span class="number">1337</span>);

<span class="keyword">var</span> createWorker = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="keyword">var</span> worker = fork(<span class="string">"./test/worker.js"</span>);
  worker.send(<span class="string">"server"</span>, server);
  workers[worker.pid] = worker;
  <span class="built_in">console</span>.log(<span class="string">"create worker. pid: "</span> + worker.pid);

  worker.on(<span class="string">"exit"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="built_in">console</span>.log(<span class="string">"worker "</span> + worker.pid + <span class="string">" exited."</span>);
    <span class="keyword">delete</span> workers[worker.pid];
    createWorker();
  });
};

<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;cpus.length; i++) {
  createWorker();
}

process.on(<span class="string">"exit"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="keyword">for</span> (pid <span class="keyword">in</span> workers) {
    workers[pid].kill();
  }
});
</code></pre><p>The code above defined a createWorker function. Every worker that is created by this function will listen to its own exit event and create a new worker process once it exits. If the master process self exits, all workers will be killed.<br>The worker.js would look like this:</p>
<pre><code><span class="comment">//worker.js</span>
<span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);

<span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span><span class="params">(req,res)</span> </span>{
  res.writeHead(<span class="number">200</span>, {<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>});
  res.end(<span class="string">'handled by child, pid is '</span> + process.pid + <span class="string">'\n'</span>);
});

process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span><span class="params">(m, tcp)</span> </span>{
  <span class="keyword">if</span>(m === <span class="string">'server'</span>) {
    tcp.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span><span class="params">(socket)</span> </span>{
      server.emit(<span class="string">'connection'</span>, socket);
    });
  }
});
</code></pre><p>Run <code>node master.js</code> to create those process.</p>
<pre><code>&gt; node master.js
create worker. <span class="string">pid:</span> <span class="number">1089</span>
create worker. <span class="string">pid:</span> <span class="number">1090</span>
create worker. <span class="string">pid:</span> <span class="number">1091</span>
create worker. <span class="string">pid:</span> <span class="number">1092</span>
</code></pre><p>Now let’s kill a process to see what’s going on.</p>
<pre><code>&gt; <span class="built_in">kill</span> <span class="number">1089</span>
worker <span class="number">1089</span> exited.
<span class="built_in">create</span> worker. pid: <span class="number">1280</span>
</code></pre><p>Aha, one exits, one created.</p>
<p>Here we just killed a process manually. In most cases, there may be some undetected bugs caused unexpected exit. So it’d better to use uncaughtException event to listen uncaught error and do some synchronous cleanup before shutting down the process. Here, for test use, we just exit process to see how it works.</p>
<pre><code><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);

<span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span><span class="params">(req,res)</span> </span>{
  res.writeHead(<span class="number">200</span>, {<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>});
  res.end(<span class="string">'handled by child, pid is '</span> + process.pid + <span class="string">'\n'</span>);
  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"throw exception"</span>);
});

<span class="keyword">var</span> worker;
process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span><span class="params">(m, tcp)</span> </span>{
  <span class="keyword">if</span>(m === <span class="string">'server'</span>) {
    worker = tcp;
    tcp.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span><span class="params">(socket)</span> </span>{
      server.emit(<span class="string">'connection'</span>, socket);
    });
  }
});

process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span><span class="params">(err)</span> </span>{
  process.send({signal: <span class="string">'suicide'</span>}); <span class="comment">//send a suicide signal to master process</span>
  worker.close(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    process.exit();
  });
});
</code></pre><p>To simulate uncaught exception, we throw an error every time there is incomint request so that every time connect to the sever, a process will exit.</p>
<p>Note that we want the master process to recreate a process once error happened instead of waiting for worker process exits to ensure incoming request would be handled as much as possible. This could be done by creating worker in message event.</p>
<pre><code><span class="keyword">var</span> createWorker = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="keyword">var</span> worker = fork(<span class="string">"./test/worker.js"</span>);
  worker.send(<span class="string">"server"</span>, server);
  workers[worker.pid] = worker;
  <span class="built_in">console</span>.log(<span class="string">"create worker. pid: "</span> + worker.pid);

  worker.on(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span><span class="params">(message)</span> </span>{
  <span class="keyword">if</span>(message.signal === <span class="string">'suicide'</span>) {
      createWorker();
  }
  });

  worker.on(<span class="string">"exit"</span>, <span class="function"><span class="keyword">function</span><span class="params">(code, sign)</span> </span>{
  <span class="built_in">console</span>.log(<span class="string">"worker "</span> + worker.pid + <span class="string">" exited."</span>);
  <span class="keyword">delete</span> workers[worker.pid];
  });
};
</code></pre><h2 id="limit_restarts">limit restarts</h2><p>One more thing to do. If the error happens when creating the process, it is not in the case of uncaughtException. That would cause unlimit process restart. To avoid this unlimit restart, it’d better to limit the number of restarts during a period of time.</p>
<pre><code><span class="comment">//master.js</span>
<span class="keyword">var</span> fork = <span class="built_in">require</span>(<span class="string">"child_process"</span>).fork,
  cpus = <span class="built_in">require</span>(<span class="string">"os"</span>).cpus(),
  server = <span class="built_in">require</span>(<span class="string">"net"</span>).createServer()
  workers = {},
  limit = <span class="number">10</span>,<span class="comment">//restart limit</span>
  restart = [];

server.listen(<span class="number">1337</span>);

<span class="keyword">var</span> isTooFrequently = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="keyword">var</span> time = <span class="built_in">Date</span>.now();
  <span class="keyword">var</span> length = restart.push(time);
  <span class="keyword">if</span>(length &gt; limit) {
    restart = restart.slice(limit * -<span class="number">1</span>);
  }
  <span class="keyword">return</span> restart.length &gt;= limit &amp;&amp; restart[restart.length -<span class="number">1</span>] -restart[<span class="number">0</span>] &lt;during;
}

<span class="keyword">var</span> createWorker = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="keyword">if</span>(isTooFrequently()) {
    process.emit(<span class="string">'giveup'</span>, length, during);
    <span class="keyword">return</span>;
  }
  <span class="keyword">var</span> worker = fork(<span class="string">"worker.js"</span>);
  worker.send(<span class="string">"server"</span>, server);
  workers[worker.pid] = worker;
  <span class="built_in">console</span>.log(<span class="string">"create worker. pid: "</span> + worker.pid);

  worker.on(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span><span class="params">(message)</span> </span>{
    <span class="keyword">if</span>(message.signal === <span class="string">'suicide'</span>) {
      createWorker();
    }
  });

  worker.on(<span class="string">"exit"</span>, <span class="function"><span class="keyword">function</span><span class="params">(code, sign)</span> </span>{
    <span class="built_in">console</span>.log(<span class="string">"worker "</span> + worker.pid + <span class="string">" exited."</span>);
    <span class="keyword">delete</span> workers[worker.pid];
  });
};

<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; cpus.length; i++) {
  createWorker();
}

process.on(<span class="string">"exit"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="keyword">for</span> (pid <span class="keyword">in</span> workers) {
    workers[pid].kill();
  }
});
</code></pre><p>This isTooFrequently function does the judgement. It emits giveup event if restarts more than 10 times in a minute.</p>
<h2 id="reference">reference</h2><ul>
<li><a href="https://book.douban.com/subject/25768396/" target="_blank" rel="external">深入浅出nodejs</a></li>
<li><a href="https://nodejs.org/api/process.html#process_signal_events" target="_blank" rel="external">Node.js v4.1.1 Documentation</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>If you have been broken, mend yourself. Knowing that you will become more beautiful. And always think before you act. an apology cannot repair something you’ve done without thought.</p>
</blockquote>
<p>Last week we talked about multi process and process communication. Today we’re going to take a look at its stability.</p>
<p>Having multi processes work together can improve the usage of our cups at some extend. But how it stability is? What if the process exits unexpected?</p>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
      <category term="tech" scheme="http://yoursite.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[understanding node process(1)]]></title>
    <link href="http://yoursite.com/2015/09/19/understanding-node-process-1/"/>
    <id>http://yoursite.com/2015/09/19/understanding-node-process-1/</id>
    <published>2015-09-19T12:52:53.000Z</published>
    <updated>2015-09-19T13:13:21.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>And Lost be the day to us in Which a measure hath not been danced.</p>
<p>And false be every truth which hath not had laughter along with it.</p>
<p>— Niezsche</p>
</blockquote>
<p>As we know, javascript is running on a single process, which brings a question, how can we get the multi-core CPU fully work?</p>
<a id="more"></a>
<h2 id="Multi-process_structure">Multi-process structure</h2><p>Fortunately, node offers us child_process moudle so that we can easily create multi-porcess and work them together.</p>
<p>First of all, we create a js file named parent.js which will create a child process and listen to it.</p>
<pre><code><span class="comment">//parent.js</span>
<span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">'child_process'</span>),
    n = cp.fork(<span class="string">'test/child.js'</span>);

n.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span><span class="params">(m)</span> </span>{
  <span class="built_in">console</span>.log(<span class="string">'parent got message: '</span>, m);
});

n.send({hello: <span class="string">'world'</span>});
</code></pre><p>Note that <code>fork</code> creates a new process whice has all the mehods in a normal ChildProcess with a build-in communication channel(Inter-Process communication channel ). So we can write to a child using <code>send</code> method.</p>
<p>what the child process does is, as same as the parent process’s, listening to the parent process. When there is message come, they print the message out.</p>
<pre><code>process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span><span class="params">(m)</span> </span>{
  <span class="built_in">console</span>.log(<span class="string">'child got meaage: '</span>, m);
});
process.send({foo: <span class="string">'bar'</span>});
</code></pre><p>Running command  <code>node parent.js</code> we can get the following:</p>
<pre><code>child got <span class="string">meaage:</span>  { <span class="string">hello:</span> <span class="string">'world'</span> }
parent got <span class="string">message:</span>  { <span class="string">foo:</span> <span class="string">'bar'</span> }
</code></pre><p>Here we go, now we have two process runing and communicating.</p>
<h2 id="the_handler_delivery">the handler delivery</h2><p>Only text message sent is probably not enough. However, we can also send TCP server or socket object as handler to another process.</p>
<pre><code><span class="comment">//parent.js</span>
<span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">'child_process'</span>),
  child = cp.fork(<span class="string">'test/child.js'</span>);

<span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'net'</span>).createServer();
server.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span><span class="params">(socket)</span> </span>{
  socket.end(<span class="string">'handled by parent\n'</span>);
});

server.listen(<span class="number">1337</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  child.send(<span class="string">'server'</span>, server);
});
</code></pre><p>the child.js would look like this:</p>
<pre><code>process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span><span class="params">(m, server)</span></span> {
  <span class="keyword">if</span>(m === <span class="string">'server'</span>) {
    server.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span><span class="params">(socket)</span></span> {
      socket.<span class="keyword">end</span>(<span class="string">'handled by child\n'</span>);
    });
  }
});
</code></pre><p>Now the server is shared between the parent and child. That means connections can be handled by either of them. Running <code>node parent.js</code> and we test it by <code>curl &quot;http://localhost:1337/&quot;</code> the result can be both.</p>
<p>What if we seperate the tasks of parent process and child process? Once the handle is sent to child process from parent process, we close the server so it no longer listens to the port.</p>
<pre><code><span class="comment">//parent.js</span>
<span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">'child_process'</span>),
    child1 = cp.fork(<span class="string">'test/child.js'</span>),
    child2 = cp.fork(<span class="string">'test/child.js'</span>);

<span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'net'</span>).createServer();

server.listen(<span class="number">1337</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  child1.send(<span class="string">'server'</span>, server);
  child2.send(<span class="string">'server'</span>, server);
  server.close();
});

server.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
  <span class="built_in">console</span>.log(<span class="string">'server closed'</span>);
})
</code></pre><p>change child.js a litte:</p>
<pre><code><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);

<span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span><span class="params">(req,res)</span> </span>{
  res.writeHead(<span class="number">200</span>, {<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>});
  res.end(<span class="string">'handled by child, pid is '</span> + process.pid + <span class="string">'\n'</span>);
});

process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span><span class="params">(m, tcp)</span> </span>{
  <span class="keyword">if</span>(m === <span class="string">'server'</span>) {
    tcp.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span><span class="params">(socket)</span> </span>{
      server.emit(<span class="string">'connection'</span>, socket);
    });
  }
});
</code></pre><p>Now we have two child processes to listen to the port. Once TCP connection is emited, we emit http connection and send client socket object to http server to do something.</p>
<p>Notice that tcp server is shard by more than one child process, It’s possible that the request is handled by differnt child process. But it’s fine. The process  service is preemptive. Depends how busy the process is, the less busy one will handle the request.</p>
<p>Even if node is running on a single process, with multi-process running, we can still better using multi-core CPU and likely to handle high loads situation.</p>
<h3 id="Reference">Reference</h3><ul>
<li><a href="https://nodejs.org/api/child_process.html" target="_blank" rel="external">Node.js v4.1.0 Documentation</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>And Lost be the day to us in Which a measure hath not been danced.</p>
<p>And false be every truth which hath not had laughter along with it.</p>
<p>— Niezsche</p>
</blockquote>
<p>As we know, javascript is running on a single process, which brings a question, how can we get the multi-core CPU fully work?</p>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
      <category term="tech" scheme="http://yoursite.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅谈javascript执行作用域]]></title>
    <link href="http://yoursite.com/2015/08/24/%E6%B5%85%E8%B0%88javascript%E6%89%A7%E8%A1%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2015/08/24/浅谈javascript执行作用域/</id>
    <published>2015-08-24T13:24:25.000Z</published>
    <updated>2015-08-24T15:49:35.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>An old Cherokee told his grandson “my son, there is a battle between 2 wolves inside us all. One is Evil. It is anger, jealousy, greed, resentment, inferiority, lies and ego. The other is Good. It’s joy, kindness, empathy and truth”. The boy thought about it and asked “Gran, which wolf wins?”. The old man quietly replied “The one you feed”.</p>
</blockquote>
<p><br></p>
<p>最近看看javascript基础知识，今天来粗浅的谈谈javascript里函数作用域。</p>
<p>说到函数作用域，就不得不提到闭包。子函数任意访问父函数的变量，并对其长期持有。父函数外部不能访问内部变量。这就是闭包。<br><a id="more"></a></p>
<p>直接上代码：</p>
<pre><code><span class="keyword">var</span> globalVariable = <span class="number">1</span>;
(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="keyword">var</span> localVariable = <span class="number">1</span>;
  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    localVariable += globalVariable;
    <span class="built_in">console</span>.log(localVariable);
  }
})();

add(); <span class="comment">// 2</span>
</code></pre><p>上面的代码结构是这样的：</p>
<pre><code><span class="list">(<span class="keyword">function</span><span class="list">()</span> <span class="collection">{ /* logic goes here */ }</span>)</span><span class="list">()</span><span class="comment">;</span>
</code></pre><p>第一个括号内定义了一个匿名函数（以下叫做一次性匿名函数），第二个括号的作用是立即执行这个函数。上面代码中的this其实是指向外部环境。this上挂载了一个add属性。这个属性的值是一个函数字面量。也就是一次性匿名函数的内部函数。之前提到子函数可以访问父函数变量并长期持有。即使一次性匿名函数执行完后被回收掉，add()仍然是存在的（因为add方法是挂载在全局的）。由于add 长期持有localVariable的引用。我们就可以通过add() 访问localVariable，这就形成了闭包。</p>
<h3 id="实例：">实例：</h3><p>在实际项目里，我就遇到了一个由于变量作用域导致的问题。应用场景大概是这样的：<br>在一个地图上画一个多边形，我有一个对象数组，这个数组里是每一个对象代表地图上多边形的每个折点。现在需要给每一个折点添加dragend事件，鼠标拖动点到新的位置时，更新对象数组中相应点的经纬度位置。起初我是这么做的：(注：以下仅是一段伪代码)</p>
<pre><code>Points = [pt1, pt2, pt3, pt4, pt5]
<span class="comment">//foreach Points as tmpPt, i</span>
<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;Points.length; i++) {
  <span class="keyword">var</span> tmpPt = Points[i];
  tmpPt.addEventListener(<span class="string">'dragend'</span>, <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>{
      Points[i].latlng = e.lat + <span class="string">','</span> + e.lng;
  });
}
</code></pre><p>可是执行的时候，无论我改变哪一个点的位置，Points中点的经纬度都没有变化。这是因为当我给每个点注册了事件后，循环结束，i已经变成了Points.length。dragend触发后程序试图修改Points[Points.length]（其实这个对象根本就不存在）。</p>
<p>这里真正需要的是在回调函数执行时能够取得该点在数组中的索引值。那么就必须把每次循环里的i变成回调函数的内部参数，使其能够长期持有。我的做法是：</p>
<pre><code>tmpPt.addEventListener(<span class="string">'dragend'</span>, (<span class="function"><span class="keyword">function</span><span class="params">(index)</span>{</span>
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(e)</span> {</span>
        Points<span class="matrix">[index]</span>.latlng = e.lat + <span class="string">','</span> + e.lng;
    }
})(<span class="built_in">i</span>)
);
</code></pre><p>注册dragend事件是会立即执行这个一次性匿名函数，把每次循环里的i作为参数传递给一次性执行函数，最后返回一个function (这个返回的function就是回调函数)。此时的i就是一次性匿名函数的内部参数。这里形成了闭包。无论鼠标拖动哪个点，都能够在回调函数中得到正确的索引值。</p>
<p>tips: 学习过程中顺便了解到了函数定义方法 var a = function(){} 和 function a(){} 的区别。 两个函数的调用和功能实现都是一致的。只是function语句（即后者）在解析时会发生被提升的情况。也就是说无论function被放置在哪里，都会被移动到所在作用域的顶层。</p>
<pre><code><span class="built_in">console</span>.log(getA); <span class="comment">// 输出结果： function getA()</span>
<span class="function"><span class="keyword">function</span> <span class="title">getA</span><span class="params">()</span></span>{
    <span class="keyword">return</span> <span class="string">'a'</span>;
}

<span class="built_in">console</span>.log(getB); <span class="comment">// 输出结果： undefined</span>
<span class="keyword">var</span> getB = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">return</span> <span class="string">'B'</span>;
}
</code></pre><p>function getA(){…}在解析时就会被提到作用域顶层。 但是为了不导致混乱，还是建议大家在写代码是先定义再调用。</p>
<h3 id="参考资料">参考资料</h3><ul>
<li><a href="http://blog.csdn.net/pusongyang/article/details/7034904" target="_blank" rel="external">再谈Javascript中function fn(){}和var fn=function(){}</a></li>
<li>javascript语言精粹</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>An old Cherokee told his grandson “my son, there is a battle between 2 wolves inside us all. One is Evil. It is anger, jealousy, greed, resentment, inferiority, lies and ego. The other is Good. It’s joy, kindness, empathy and truth”. The boy thought about it and asked “Gran, which wolf wins?”. The old man quietly replied “The one you feed”.</p>
</blockquote>
<p><br></p>
<p>最近看看javascript基础知识，今天来粗浅的谈谈javascript里函数作用域。</p>
<p>说到函数作用域，就不得不提到闭包。子函数任意访问父函数的变量，并对其长期持有。父函数外部不能访问内部变量。这就是闭包。<br>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="tech" scheme="http://yoursite.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[What we lost?]]></title>
    <link href="http://yoursite.com/2015/08/13/What-we-lost/"/>
    <id>http://yoursite.com/2015/08/13/What-we-lost/</id>
    <published>2015-08-13T14:24:56.000Z</published>
    <updated>2015-08-13T14:31:32.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>In the age of acceleration, nothing can be more exhilarating than going slow. And in the age of distraction, nothing is so luxurious as paying attention. And in the age of constant movement, nothing is so urgent as sitting still.</p>
</blockquote>
<p>Technologe brings our life into a new stage of century. Everything is rising faster and faster. And it means to be used by saving time. But why we still feel lack of time, even more than before? What we lost when we are all rushing into the entire new age?</p>
<a id="more"></a>
<p>In this complete fast going world, we work longer, spending more time on social network instead of being with friends and family in real life. I can’t belive technology is actually cutting off the connection between people. It’s hard to feel the surroundings with all your heart. And certainly, most of us, including me, read people’s life through something called Internet, something called fackbook, wechat comment and other social apps. It, however, is huge waste of time. Because I don’t need to read people’s life but join it.</p>
<p>This is not the first time I feel that my life is going faster than I can be with. We all do. Since last year, while I was rushing into the future, all I heard in my head is noisy, the noisy from outside world. I was the most anxious,emotional painful than I ever felt, which brought me to the hell. I was crying a few times a day. without any reason. Everything that is happening can be the trigger to make me cry. My life was such a mess. I lost the inner peace. I lost the balance between inside and outside. There was nothing I can do to save my life until I went maditating again. What I found out is that the more I was emotional uncomfortable, the more concentrated I can be.</p>
<p>Maditating is slowing me down and preventing me from rushing into the furture. Technologe dose excellent work by improving work efficiency if it’s used correctly. However, it also bring us the side effects of life. What technologe hasn’t always given us is a sense of how to wisest use of technology. In return, it perhaps makes you more tired, confused instead.</p>
<p>This world is much more powerful, infomative. We all go too fast and want to take advantage of it. But on the other hand, it costs more on real personal life.  It’s hard to keep peace inside, that’s also exactly what outside world make us suffer by. Maybe the only way to keep ourselves, our sprits, survive from it is slowing down, feeling things around you with all your heart. The smile of people, the sounds of laughing, the sensation of touching things, and the feeling when you hug people etc.</p>
<p>Meditation ,for me, is not only about sitting down. When you do something with 100% concentration. You are being the present, you are meditating. It’s hard to explain how it changed me. And I’m still trying. But it works. It works well.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>In the age of acceleration, nothing can be more exhilarating than going slow. And in the age of distraction, nothing is so luxurious as paying attention. And in the age of constant movement, nothing is so urgent as sitting still.</p>
</blockquote>
<p>Technologe brings our life into a new stage of century. Everything is rising faster and faster. And it means to be used by saving time. But why we still feel lack of time, even more than before? What we lost when we are all rushing into the entire new age?</p>]]>
    
    </summary>
    
      <category term="life" scheme="http://yoursite.com/tags/life/"/>
    
      <category term="meditation" scheme="http://yoursite.com/tags/meditation/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[gulp学习初体验]]></title>
    <link href="http://yoursite.com/2015/06/21/gulp%E5%AD%A6%E4%B9%A0%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://yoursite.com/2015/06/21/gulp学习初体验/</id>
    <published>2015-06-21T13:02:53.000Z</published>
    <updated>2015-06-21T16:05:37.000Z</updated>
    <content type="html"><![CDATA[<p>花了一天的时间，把gulp的一些基本用法过了一遍。总算对其有了些了解。记录下学习中的不解，也算对这次的学习一个总结。</p>
<p>首先介绍一下gulp，gulp是一个前端构建工具，利用它可以在项目开发过程中自动化执行任务。有赖于其强大的插件系统，我们可以利用gulp完成很多任务，例如执行JSHint，编译stylus，更新版本号等。</p>
<a id="more"></a>
<h2 id="安装gulp：">安装gulp：</h2><p>全局安装：</p>
<pre><code>npm <span class="keyword">install</span> -g gulp
</code></pre><p>项目安装：</p>
<pre><code>npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> gulp
</code></pre><p>—save-dev 安装包将在开发环境下安装，版本信息写入package.json的devDependencies下。</p>
<p>gulp任务都定义在gulpfile.js中，可以在终端运行gulp命令来执行。</p>
<h2 id="gulp任务">gulp任务</h2><p>加载gulp模块</p>
<pre><code><span class="reserved">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);
</code></pre><p>其他gulp插件的加载也是一样。</p>
<p>下面是一段编译stylus的gulp task代码，用来简单解释一下gulp的工作流程。</p>
<pre><code>gulp.task(<span class="string">'stylus'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
  gulp.src(<span class="string">'./assets/stylus/style.styl'</span>)
      .pipe(stylus())
      .pipe(gulp.dest(<span class="string">'./assets/stylesheets'</span>));
});
</code></pre><p>gulp.task(taskName, excutor)用来定义任务。需要任务名和执行函数两个参数。执行函数也可以是多个任务。</p>
<p>gulp.task(‘build’, [‘task’, ‘anotherTask’]);</p>
<p>但是这些任务不是顺序执行的。要保证一个任务先于另一个执行可以：</p>
<pre><code>gulp.task(<span class="string">'taskTwo'</span>, [<span class="string">'taskOne'</span>], <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
   <span class="comment">// taskTwo</span>
});
</code></pre><p>taskTwo 会在 taskOne执行完后再执行。</p>
<p>gulp.src()函数用来匹配文件，创建一个对象流来代表这些文件，之后的操作都是以这些文件为对象进行操作。pipe顾名思义就是管道的意思， stylus()返回修改后的文件对象放入流中，这些输出的文件随着管道被输入到gulp.dest()函数中并保持下来。</p>
<p>最后不要忘记在文件头部加载gulp-stylus模块。</p>
<h2 id="运行gulp">运行gulp</h2><p>终端执行 <code>$ gulp</code> 会报错，因为gulp默认会执行default 任务。需要在gulpfile.js内定义此任务</p>
<pre><code>gulp.task(<span class="string">'default'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
  <span class="comment">//deal with default task</span>
})
</code></pre><p>如果要运行指定任务</p>
<pre><code><span class="variable">$ </span>gulp taskName
</code></pre><h2 id="watching_files">watching files</h2><p>用gulp来监听文件的修改状态非常方便。我们来定义一个watch任务看一下</p>
<pre><code>gulp.task(<span class="string">'watch'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
  gulp.watch(<span class="string">'./assets/stylus/*.styl'</span>, [<span class="string">'stylus'</span>]);
});
</code></pre><p>现在当改变styl文件时就会执行stylus任务。</p>
<p>当然仅仅是watch是不够的，我们还希望在文件修改的同时浏览器能同步更新。browserSync插件就可以做到。当改变代码的时候，BrowserSync会重新加载页面，如果是css文件，会直接添加进css中，页面并不需要再次刷新。这样我们修改前端代码时就不需要每次都手动刷新浏览器。</p>
<pre><code><span class="tag">gulp</span><span class="class">.task</span>(<span class="string">'browser-sync'</span>, <span class="function">function</span>(){
  <span class="tag">browserSync</span><span class="class">.init</span>(null, {
    <span class="attribute">proxy</span>: <span class="string">'http://localhost:3000'</span>,
    <span class="attribute">files</span>: [<span class="string">'assets/stylesheets/*.css'</span>],
    <span class="attribute">browser</span>: <span class="string">'google-chrome'</span>,
    <span class="attribute">port</span>: <span class="number">7000</span>,
    <span class="attribute">reloadOnRestart</span>: false
  });
});
<span class="tag">gulp</span><span class="class">.task</span>(<span class="string">'default'</span>, [<span class="string">'browser-sync'</span>]);
</code></pre><p>gulp运行时会默认执行browser-sync任务。启动browserSync，监听css文件的改变并在chrome中加载更新的部分。</p>
<blockquote>
<p> proxy: vhost url<br> files: 监听改变的文件<br> port: browser侦测改变的端口</p>
</blockquote>
<p>browserSync主要监听浏览器端的改变，要监听更新服务端需要用到nodemon</p>
<pre><code>gulp.task(<span class="string">'nodemon'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
  <span class="keyword">return</span> nodemon({
    script: <span class="string">'bin/www'</span>,
    ext: <span class="string">'js'</span>
  }).on(<span class="string">'start'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{

  });
});
</code></pre><p>项目开发是基于express， 这段代码会执行bin/www文件运行服务端，并监听js文件的改变，每次改变重启服务。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>花了一天的时间，把gulp的一些基本用法过了一遍。总算对其有了些了解。记录下学习中的不解，也算对这次的学习一个总结。</p>
<p>首先介绍一下gulp，gulp是一个前端构建工具，利用它可以在项目开发过程中自动化执行任务。有赖于其强大的插件系统，我们可以利用gulp完成很多任务，例如执行JSHint，编译stylus，更新版本号等。</p>]]>
    
    </summary>
    
      <category term="front-end" scheme="http://yoursite.com/tags/front-end/"/>
    
      <category term="tech" scheme="http://yoursite.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[双线部署遇到的问题]]></title>
    <link href="http://yoursite.com/2015/05/03/%E5%8F%8C%E7%BA%BF%E9%83%A8%E7%BD%B2%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2015/05/03/双线部署遇到的问题/</id>
    <published>2015-05-03T07:23:20.000Z</published>
    <updated>2015-05-09T15:35:26.000Z</updated>
    <content type="html"><![CDATA[<p>本来博客是放在github上面，但是由于国内网络环境（大家懂的），github访问不是很稳定，随时被查水表。所以采取网友的建议，在gitcafe也部署一个。gifcafe是国内的，速度杠杠的～</p>
<a id="more"></a>
<p>这样国内访问走gitcafe，国外访问走github，再做个dnspod双线解析就大功告成。</p>
<p>下面纪录重新双线部署过程中遇到的问题，作学习之用。</p>
<p>hexo部署单个平台没有问题，但是添加一个gitcafe，再deploy就报错了。</p>
<blockquote>
<p>deploy:<br>- type: git<br>  repository: github url<br>  branch: master<br>- type: git<br>  repository: gitcafe url<br>  branch: gitcafe-pages</p>
</blockquote>
<p>github可以正常deploy，gitcafe报错：permission denied。 我想应该是生成的ssh key出了问题。</p>
<p>这里简单说一下ssh key， 为了避免没错连接到github或gitcafe都要输入密码，可以用邮件地址在本地生成id_rsa 和 id_rsa.pub，前者是私钥自己保存，后者是公钥需要添加到github和gitcafe，这样就不用每次连接都输入密码做身份验证了。关于ssh key的生成请戳<a href="https://help.github.com/articles/generating-ssh-keys/" target="_blank" rel="external">这里</a>。</p>
<p>我之前是针对github和gitcafe分别生成了id_rsa,id_rsa.pub和cafe_rsa和cafe_rsa.pub。</p>
<p>但是问题来了，这么多私钥ssh不知道应该用哪一个。其实~/.ssh/id_rsa是基本私钥，ssh总是把它当作提交私钥的首选项。但是如果存在其他的私钥，就需要向ssh提及，好像登记样，并且配置~/.ssh下config文件来指定不同host应该使用的私钥文件。具体看下面：</p>
<pre><code>ssh-<span class="keyword">add</span> ~/.ssh/cafe_rsa
</code></pre><p>检查是否添加成功：</p>
<pre><code>ssh-<span class="keyword">add</span> -l
</code></pre><p>如果是这样就成功了：</p>
<blockquote>
<p>2048 dc:0f:0d:5b:…:a0:0b:a7:d3:62:a6:bc:bc /Users/username/.ssh/id_rsa (RSA)<br>2048 d8:2c:1c:25:…:56:14:c7:79:7e:20:43:20 /Users/username/.ssh/cafe_rsa (RSA)</p>
</blockquote>
<p>config文件的配置：</p>
<blockquote>
<p>Host username.github.com<br>HostName github.com<br>User git<br>IdentityFile ~/.ssh/id_rsa</p>
<p>Host username.gitcafe.com<br>HostName gitcafe.com<br>User git<br>IdentityFile ~/.ssh/cafe_rsa</p>
</blockquote>
<p>同理，如果是一个平台有多个用户，只需要添加相同的项并修改Host的username就行了～</p>
<p>但是我想同时生成那么多key也不是很方便，所以取消了cafe_rsa,直接把id_rsa.pub作为github和gitcafe的ssh key。这样两个平台就公用一个本地私钥。也不用再去设置什么config文件。需要注意的是，生成密钥的邮箱和我github，gitcafe的邮箱是一样的。</p>
<p>再修改一下hexo的_config.yml文件：</p>
<blockquote>
<p>deploy:<br> type: git<br> repository:<br>   github: git@username.github.com:username/username.github.io.git,[branch]<br>   gitcafe: git@username.gitcafe.com:username/username.git,[branch]</p>
</blockquote>
<p>这下就可以同时对两个平台进行部署，尽情发布了～</p>
<h6 id="参考资料">参考资料</h6><ul>
<li><a href="http://wshuyi.github.io/2014/08/22/hexoGithubGitCafe20140822/" target="_blank" rel="external">在github和gitcafe上同时部署hexo博客</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>本来博客是放在github上面，但是由于国内网络环境（大家懂的），github访问不是很稳定，随时被查水表。所以采取网友的建议，在gitcafe也部署一个。gifcafe是国内的，速度杠杠的～</p>]]>
    
    </summary>
    
      <category term="issue" scheme="http://yoursite.com/tags/issue/"/>
    
      <category term="tech" scheme="http://yoursite.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[setup Macbook]]></title>
    <link href="http://yoursite.com/2015/05/02/setup-Macbook/"/>
    <id>http://yoursite.com/2015/05/02/setup-Macbook/</id>
    <published>2015-05-02T15:35:56.000Z</published>
    <updated>2015-05-03T09:11:04.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>工欲善其事，必先利其器</p>
</blockquote>
<p>折腾了两天，终于把新到手的Macbook 各种配置好！ 中间遇到的问题不是一般两般的多，谁叫我是新手呢！！！</p>
<a id="more"></a>
<h2 id="开发">开发</h2><p>最开始的开始，当然是xcode了，很多安装都需要xcode ready first。</p>
<ul>
<li><p>Homebrew： 很好用的包管理工具，后期安装一些应用、插件之类的很方便。</p>
</li>
<li><p>Iterm2 \＋ zsh: 我的最爱，强大的终端。<br><img src="https://iterm2.com/img/screenshots/split_panes_full.png" alt="Iterm2"><br>新手看起来瞬间高大上有木有～</p>
</li>
<li><p>Git： 她的美不言而喻。</p>
</li>
<li><p>Node.js： 有好多东西要学，先抓node。</p>
</li>
<li><p>NPM： Node的包管理系统，安装很方便～</p>
<ul>
<li><p>gulp： npm安装包。</p>
</li>
<li><p>bower： 另一个包管理工具，不要问我为什么那么多包管理工具～</p>
</li>
</ul>
</li>
</ul>
<h2 id="设计">设计</h2><p>Mac怎么能没有设计软件来配成。</p>
<ul>
<li><p>Adobe Photoshop CC</p>
</li>
<li><p>Adobe Lightroom (optional)</p>
</li>
<li><p>Adobe Illustrator (optional)</p>
</li>
<li><p>Sketch (optional)</p>
</li>
</ul>
<h2 id="网络">网络</h2><p>最后当然少不了穿越，你们懂得～</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>工欲善其事，必先利其器</p>
</blockquote>
<p>折腾了两天，终于把新到手的Macbook 各种配置好！ 中间遇到的问题不是一般两般的多，谁叫我是新手呢！！！</p>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://yoursite.com/tags/Mac/"/>
    
      <category term="front-end" scheme="http://yoursite.com/tags/front-end/"/>
    
  </entry>
  
</feed>