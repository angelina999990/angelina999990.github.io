<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Angelina ZX]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-01-28T02:28:56.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Angelina ZX]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[understanding express(2)之expressJS接收和处理http请求过程]]></title>
    <link href="http://yoursite.com/2016/01/28/understanding-express-2/"/>
    <id>http://yoursite.com/2016/01/28/understanding-express-2/</id>
    <published>2016-01-27T16:08:16.000Z</published>
    <updated>2016-01-28T02:28:56.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>Have the courage to follow your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary</p>
</blockquote>
<p>今天来了解整个接收和处理请求的过程。</p>
<p><a href="http://angelina999990.gitcafe.io/2016/01/25/understanding-expressJS/" target="_blank" rel="external">上一章</a>说了当接收到一个请求的时候是通过这个函数 <code>app.handle(req, res, next);</code> 来处理请求的。今天来说一下具体一个请求的处理过程。</p>
<p>收到请求会执行<code>app.handle(req, res, next)</code>，具体代码如下：</p>
<a id="more"></a>
<pre><code><span class="comment">//application.js</span>
app.handle = <span class="function"><span class="keyword">function</span><span class="params">(req, res, done)</span> </span>{
  <span class="keyword">var</span> router = <span class="keyword">this</span>._router;

  <span class="comment">// final handler</span>
  done = done || finalhandler(req, res, {
    env: <span class="keyword">this</span>.<span class="keyword">get</span>(<span class="string">'env'</span>),
    onerror: logerror.bind(<span class="keyword">this</span>)
  });

  <span class="comment">// no routes</span>
  <span class="keyword">if</span> (!router) {
    debug(<span class="string">'no routes defined on app'</span>);
    done();
    <span class="keyword">return</span>;
  }

  router.handle(req, res, done);
};
</code></pre><p>这个函数接收三个参数req，res，next。 其中next就是上面的done, 默认是finalhandler。具体可以看<a href="https://github.com/pillarjs/finalhandler" target="_blank" rel="external">这里</a>。然后调用router.handle()开始链式调用。</p>
<p>router.handler 代码比较长，先看结构：</p>
<pre><code><span class="comment">// router/index.js</span>
proto.handle = <span class="function"><span class="keyword">function</span><span class="params">(req, res, done)</span> </span>{
  ...... <span class="comment">//定义一些基本变量</span>

  next();

  <span class="function"><span class="keyword">function</span> <span class="title">next</span><span class="params">(err)</span> </span>{
    ......
  }

  <span class="function"><span class="keyword">function</span> <span class="title">trim_prefix</span><span class="params">(layer, layerError, layerPath, path)</span> </span>{
    ...... <span class="comment">//对路径做些处理再调用layer.handle_request</span>
  }
};
</code></pre><p>其中通过递归调用next()来遍历stack(存放中间件的栈，是一个数组)看是否有匹配的中间件。在proto.handle的开头就定义了idx=0，表示当前中间件索引。在next()中首先判断当前中间件索引是否大于stack.length。 如果是说明已遍历完，直接执行done()。</p>
<pre><code>// <span class="keyword">function</span> next()
<span class="keyword">if</span> (idx &gt;= stack.length) {
  <span class="built_in">set</span>Immediate(<span class="keyword">done</span>, layerError);
  <span class="built_in">return</span>;
}
</code></pre><p>否则的话执行while循环找到第一个可以处理http请求的中间件。 来看一下while的主要代码：</p>
<pre><code>// function next()
<span class="keyword">var</span> layer;
<span class="keyword">var</span> match;
<span class="keyword">var</span> route;

<span class="keyword">while</span> (match !== <span class="literal">true</span> &amp;&amp; idx &lt; stack.length) {
  layer = stack[idx++];
  match = matchLayer(layer, path);  //调用了layer.match 方法
  route = layer.route;

  <span class="keyword">if</span> (typeof match !== 'boolean') {
    layerError = layerError || match;
  }

  <span class="keyword">if</span> (match !== <span class="literal">true</span>) {
    <span class="keyword">continue</span>; // 不匹配，退出本次循环。
  }

  <span class="keyword">if</span> (!route) {
    <span class="keyword">continue</span>;
  }

  <span class="keyword">if</span> (layerError) {
    match = <span class="literal">false</span>;
    <span class="keyword">continue</span>;
  }

  <span class="keyword">var</span> <span class="keyword">method</span> = req.<span class="keyword">method</span>;
  <span class="keyword">var</span> has_method = route._handles_method(<span class="keyword">method</span>);

  <span class="keyword">if</span> (!has_method &amp;&amp; <span class="keyword">method</span> === '<span class="type">OPTIONS</span>') {
    appendMethods(options, route._options());
  }

  <span class="keyword">if</span> (!has_method &amp;&amp; <span class="keyword">method</span> !== '<span class="type">HEAD</span>') {
    match = <span class="literal">false</span>;
    <span class="keyword">continue</span>;
  }
}
</code></pre><p>通过matchLayer确定当前layer是否与当前路径匹配。不匹配则直接结束本次循环进入下一个中间件的判断。match为true但是layer.route不存在，说明不是路由中间件，结束本次循环，由于此时match为true会结束while循环直接进入下面的步骤（这个稍后说）。 如果route存在，即是路由中间件，再判断该路由可处理的http方法是否与请求的http方法一致。如果不一致则根据其method是否为options或head做相应处理，一致则不再对match做修改，这样执行下次while循环的时候由于match为true会结束循环进入下面的步骤。</p>
<pre><code>// <span class="function"><span class="keyword">function</span> <span class="title">next</span><span class="params">()</span></span> 结束<span class="keyword">while</span>循环后的部分

<span class="keyword">if</span> (match !== <span class="keyword">true</span>) {
   //结束循环后match仍然为<span class="keyword">false</span>, 说明是遍历完stack, 没有匹配的中间件
  <span class="keyword">return</span> done(layerError);
}

<span class="keyword">if</span> (route) {
  req.route = route;
}

req.params = self.mergeParams
  ? mergeParams(layer.params, parentParams)
  : layer.params;
var layerPath = layer.path;

self.process_params(layer, paramcalled, req, res, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span></span> {
  <span class="keyword">if</span> (err) {
    <span class="keyword">return</span> <span class="built_in">next</span>(layerError || err);
  }

  <span class="keyword">if</span> (route) {
    //<span class="built_in">next</span>作为回调函数传入handle_request,形成一个闭包，再在handle_request中调用<span class="built_in">next</span>()的时候idx的值仍然是上一次退出<span class="keyword">while</span>循环的值
    <span class="keyword">return</span> layer.handle_request(req, res, <span class="built_in">next</span>);
  }

  //对路径做些处理再调用layer.handle_request
  trim_prefix(layer, layerError, layerPath, path);
});
</code></pre><p>这部分首先进行一些参数预处理，如果为路由中间件就直接调用layer.handle_request，否则先对路径做些处理再调用layer.handle_request。下面是layer.handle_request的代码：</p>
<pre><code><span class="comment">// router/layer.js</span>
Layer.prototype.handle_request = <span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">(req, res, next)</span> </span>{
  <span class="keyword">var</span> fn = <span class="keyword">this</span>.handle;

  <span class="keyword">if</span> (fn.length &gt; <span class="number">3</span>) {
    <span class="comment">// not a standard request handler</span>
    <span class="keyword">return</span> next();
  }

  <span class="keyword">try</span> {
    fn(req, res, next);
  } <span class="keyword">catch</span> (err) {
    next(err);
  }
};
</code></pre><p>layer.handle_request会在Router.handle和route.dispatch中调用。注意若是从Router.handle调用的，next是Router.handle里定义的next，若是从route.dispatch调用的，next是dispatch里定义的next。 不同的next遍历的对象有所不同。举个🌰：</p>
<pre><code><span class="comment">//app.js</span>
    <span class="keyword">var</span> user = <span class="keyword">require</span>(<span class="string">'user'</span>);
    <span class="keyword">var</span> app = express();

    app.<span class="keyword">use</span>(<span class="string">'/index'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="comment">//do something</span>
    })
    app.<span class="keyword">use</span>(<span class="string">'/user'</span>, user);


<span class="comment">//user.js</span>
    <span class="keyword">var</span> userRouter = <span class="keyword">require</span>(<span class="string">'express'</span>).Router();
    <span class="keyword">var</span> checkAuth = <span class="function"><span class="keyword">function</span><span class="params">(req, res, next)</span></span>{
        <span class="comment">//... check auth</span>
        next()
    };
    <span class="keyword">var</span> getList = <span class="function"><span class="keyword">function</span><span class="params">(req, res, next)</span> </span>{
        <span class="comment">//... get user list</span>
    }

    userRouter.get(<span class="string">'/list'</span>, checkAuth, getList);
    module.exports = userRouter;
</code></pre><p>app.js中的两个app.use其实是调用router.use创建了两个layer对象并将其添加到app._router.stack中，以下简称Router。Router.stack应该是类似这样的<code>[ layer1, layer2 ]</code>。 其中layer2实际上是express.Router()的导出对象, 在app.use方法中会视为一个子app封装一层。像这样：</p>
<pre><code><span class="comment">//application.js app.use()</span>
<span class="function"><span class="keyword">function</span> <span class="title">mounted_app</span><span class="params">(req, res, next)</span> </span>{
  <span class="keyword">var</span> orig = req.app;
  fn.handle(req, res, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>{
    req.__proto__ = orig.request;
    res.__proto__ = orig.response;
    next(err);
});
</code></pre><p>这里的fn实际上就是<code>app.use(&#39;/user&#39;,user)</code>中的user（即user.js中导出的Router）。完整代码可查看application.js 的app.use。</p>
<p>上面user.js中调用userRouter.get方法创建一个新的route和layer（这里暂时叫newLayer, 这个layer会被push到userRouter.stack中）， 再调用route.get方法把checkAuth和getList添加到route.stack中，所以该route的stack应该类似这样 <code>[ layer3, layer4 ]</code>，userRouter.stack是这样的<code>[ newLayer ]</code>。 这里附上Router.route和 Router.VERB的代码。</p>
<pre><code>// router/index.js
proto.route = function(path){
  <span class="keyword">var</span> route = new <span class="type">Route</span>(path);

  <span class="keyword">var</span> layer = new <span class="type">Layer</span>(path, {
    sensitive: this.caseSensitive,
    strict: this.strict,
    <span class="keyword">end</span>: <span class="literal">true</span>
  }, route.dispatch.<span class="keyword">bind</span>(route)); //layer.handle=route.dispatch

  layer.route = route;

  this.stack.push(layer);
  <span class="keyword">return</span> route;
};

// 创建 <span class="type">Router</span><span class="comment">#VERB functions</span>
methods.concat('all').forEach(function(<span class="keyword">method</span>){
  proto[<span class="keyword">method</span>] = function(path){

    // 调用proto.route new 一个route对象。
    <span class="keyword">var</span> route = this.route(path)

    //在route.<span class="type">VERB</span>或route.all中会把传入的fn添加到该route的stack中
    route[<span class="keyword">method</span>].apply(route, slice.call(arguments, <span class="number">1</span>));
    <span class="keyword">return</span> this;
  };
});
</code></pre><p>所以当收到一个http请求(eg. <a href="http://host.com/user/list)，" target="_blank" rel="external">http://host.com/user/list)，</a> 首先执行app.handle(), 在 <code>[layer1, layer2]</code>中查找匹配，当查找的layer2的时候，路径匹配且layer2不是一个路由中间件，进入到layer.handle_request调用layer.handle(这里的layer.handle就是mounted_app方法),里面又调用fn.handle就是执行userRouter.handle方法，又继续在userRouter.stack（<code>[ newLayer ]</code>）中查找匹配, newLayer路径与请求路径匹配且是路由中间件，进入layer.handle_request执行layer.handle，注意这里的layer.handle是route.dispatch，因为在Router.VERB中创建layer时是<code>new Layer(path, option, route.dispatch.bind(route))</code>。所以就会在route.stack(<code>[ layer3, layer4 ]</code>)中查找匹配。附上route.dispatch代码：</p>
<pre><code><span class="type">Route</span>.prototype.dispatch = function(req, res, done){
  <span class="keyword">var</span> idx = <span class="number">0</span>;
  <span class="keyword">var</span> stack = this.stack;
  <span class="keyword">if</span> (stack.length === <span class="number">0</span>) {
    <span class="keyword">return</span> done();
  }

  <span class="keyword">var</span> <span class="keyword">method</span> = req.<span class="keyword">method</span>.toLowerCase();
  <span class="keyword">if</span> (<span class="keyword">method</span> === 'head' &amp;&amp; !this.methods['head']) {
    <span class="keyword">method</span> = 'get';
  }

  req.route = this;

  next();

  function next(err) {
    <span class="keyword">if</span> (err &amp;&amp; err === 'route') {
      <span class="keyword">return</span> done();
    }

    <span class="keyword">var</span> layer = stack[idx++];
    <span class="keyword">if</span> (!layer) {
      <span class="keyword">return</span> done(err);
    }

    <span class="keyword">if</span> (layer.<span class="keyword">method</span> &amp;&amp; layer.<span class="keyword">method</span> !== <span class="keyword">method</span>) {
      <span class="keyword">return</span> next(err);
    }

    <span class="keyword">if</span> (err) {
      layer.handle_error(err, req, res, next);
    } <span class="keyword">else</span> {
      layer.handle_request(req, res, next);
    }
  }
};
</code></pre><p>可以看到这里的idx是0，与Router.handle()中的idx不同，route.dispatch是在当前route.stack中遍历匹配。在上面的🌰中route.stack就是<code>[ layer3, layer4 ]</code>。处理逻辑与Router.handle类似，idx是当前下表，stack是当前路由处理函数列表，递归调用next。 这里next方法判断当前layer是否存在，不存在或方法不匹配调用done, 否则根据err值执行handle_request或handle_error。例子中的layer3路径和method都匹配，执行layer3.handle_request调用this.handle即checkauth方法，如果通过验证就会执行next(),注意这时的next是dispatch中定义的next方法。此时idx指向layer4, 依然匹配，继续执行getList方法。 getList执行后若不再调用next(), 则处理请求的过程结束， 否则继续执行next, 此时route.stack遍历完再找不到layer会执行done(err) 返回到<code>[newLayer]</code>层面，userRouter.stack也遍历完（userRouter.handle中的idx此时为1，大于<code>[newLayer].length</code>）于是又调用done, 回到上层的Router.stack中(<code>[layer1, layer2]</code>)依次类推。当热由于getList处理完请求后直接reponse所以不会再调用next()。 这里只是分析下如果继续调用next的行为。</p>
<p>表述得可能不太清楚，看图：</p>
<p><img src="http://d.pcs.baidu.com/thumbnail/c9ddf27e2239ce53983f5628faab78de?fid=571110063-250528-341365159016922&amp;time=1453910400&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-89IEUyBrNLkIrRrkm0IX4DReUj4%3D&amp;rt=sh&amp;expires=2h&amp;r=914482467&amp;sharesign=unknown&amp;size=c710_u500&amp;quality=100" alt="http请求处理过程"></p>
<h3 id="Reference">Reference</h3><ul>
<li><a href="https://github.com/syaning/understanding-express" target="_blank" rel="external">express源码解析</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>Have the courage to follow your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary</p>
</blockquote>
<p>今天来了解整个接收和处理请求的过程。</p>
<p><a href="http://angelina999990.gitcafe.io/2016/01/25/understanding-expressJS/">上一章</a>说了当接收到一个请求的时候是通过这个函数 <code>app.handle(req, res, next);</code> 来处理请求的。今天来说一下具体一个请求的处理过程。</p>
<p>收到请求会执行<code>app.handle(req, res, next)</code>，具体代码如下：</p>]]>
    
    </summary>
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[understanding expressJS (1)]]></title>
    <link href="http://yoursite.com/2016/01/25/understanding-expressJS/"/>
    <id>http://yoursite.com/2016/01/25/understanding-expressJS/</id>
    <published>2016-01-25T12:39:34.000Z</published>
    <updated>2016-01-27T16:10:18.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>Working like don’t need money, dancing like no one’s watching, love like never get hurt</p>
</blockquote>
<p>这里主要了解一下启动一个express 应用的过程</p>
<pre><code><span class="comment">//express.js</span>
function createApplication() {
  <span class="keyword">var</span> <span class="keyword">app</span> = function(req, res, next) {
    <span class="keyword">app</span>.handle(req, res, next);
  };

  mixin(<span class="keyword">app</span>, EventEmitter.prototype, false);
  mixin(<span class="keyword">app</span>, proto, false);

  <span class="keyword">app</span>.request = { __proto__: req, <span class="keyword">app</span>: <span class="keyword">app</span> };
  <span class="keyword">app</span>.response = { __proto__: res, <span class="keyword">app</span>: <span class="keyword">app</span> };
  <span class="keyword">app</span>.init();
  <span class="keyword">return</span> <span class="keyword">app</span>;
}
</code></pre><a id="more"></a>
<p>express.js 实际上定义导出了一个createApplication的函数。express()实际上是得到了一个app的实例。</p>
<pre><code><span class="keyword">mixin</span>(app, proto, <span class="literal">false</span>);
</code></pre><p>这段代码的作用就是把application.js下定义的属性扩展到app上。</p>
<pre><code><span class="comment">// bin/www</span>
<span class="variable"><span class="keyword">var</span> server</span> = http.createServer(app);
</code></pre><p>http.createServer 接受一个函数作为request事件的回调函数。实际下面这种写法也是一样的。</p>
<pre><code>var <span class="keyword">server</span> = http.createServer();
<span class="keyword">server</span>.on(<span class="string">'request'</span>, app);
</code></pre><p>这里传到createServer的app就是上面得到的app实例（实际就是一个函数）。在接收到http请求时会执行app.handle 方法。app.handle 方法定义如下：</p>
<pre><code><span class="comment">//application.js</span>
app.handle = <span class="function"><span class="keyword">function</span><span class="params">(req, res, done)</span> </span>{
  <span class="keyword">var</span> router = <span class="keyword">this</span>._router;

  <span class="comment">// final handler</span>
  done = done || finalhandler(req, res, {
    env: <span class="keyword">this</span>.<span class="keyword">get</span>(<span class="string">'env'</span>),
    onerror: logerror.bind(<span class="keyword">this</span>)
  });

  <span class="comment">// no routes</span>
  <span class="keyword">if</span> (!router) {
    debug(<span class="string">'no routes defined on app'</span>);
    done();
    <span class="keyword">return</span>;
  }

  router.handle(req, res, done);
};
</code></pre><p>this._router(即app._router)实际上是在app.lazyrouter方法中new的一个Router对象, 一般在定义中间件的时候会用到这个方法来给app添加一个_router属性。 所以上面的app.handle 其实是router.handle的一个代理方法，最终还是调用的router.handle()。至于具体处理请求的过程另写一遍具体介绍。</p>
<p>回到www/bin文件</p>
<pre><code>var <span class="keyword">port</span> = normalizePort(<span class="keyword">process</span>.env.<span class="keyword">PORT</span> || '<span class="number">3001</span>');
app.set(<span class="attribute">'port</span>', <span class="keyword">port</span>);

var server = http.createServer(app);

server.listen(<span class="keyword">port</span>);
server.<span class="keyword">on</span>(<span class="attribute">'error</span>', onError);
server.<span class="keyword">on</span>(<span class="attribute">'listening</span>', onListening);
</code></pre><p>这里首先增加port属性到app.js。 然后创建一个http server 并监听它的request, err, listening时间。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>Working like don’t need money, dancing like no one’s watching, love like never get hurt</p>
</blockquote>
<p>这里主要了解一下启动一个express 应用的过程</p>
<pre><code><span class="comment">//express.js</span>
function createApplication() {
  <span class="keyword">var</span> <span class="keyword">app</span> = function(req, res, next) {
    <span class="keyword">app</span>.handle(req, res, next);
  };

  mixin(<span class="keyword">app</span>, EventEmitter.prototype, false);
  mixin(<span class="keyword">app</span>, proto, false);

  <span class="keyword">app</span>.request = { __proto__: req, <span class="keyword">app</span>: <span class="keyword">app</span> };
  <span class="keyword">app</span>.response = { __proto__: res, <span class="keyword">app</span>: <span class="keyword">app</span> };
  <span class="keyword">app</span>.init();
  <span class="keyword">return</span> <span class="keyword">app</span>;
}
</code></pre>]]>
    
    </summary>
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Understanding node process (2)]]></title>
    <link href="http://yoursite.com/2015/09/26/Understanding-node-process-2/"/>
    <id>http://yoursite.com/2015/09/26/Understanding-node-process-2/</id>
    <published>2015-09-26T09:56:26.000Z</published>
    <updated>2015-09-26T10:05:57.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>If you have been broken, mend yourself. Knowing that you will become more beautiful. And always think before you act. an apology cannot repair something you’ve done without thought.</p>
</blockquote>
<p>Last week we talked about multi process and process communication. Today we’re going to take a look at its stability.</p>
<p>Having multi processes work together can improve the usage of our cups at some extend. But how it stability is? What if the process exits unexpected?</p>
<a id="more"></a>
<p>node’s child_process does have some events available here so we can take advantage of those events listener to manage our process.</p>
<h2 id="process_restart">process restart</h2><p>Let’s first listen to its exit event and create a new one when process exits.</p>
<pre><code><span class="comment">// master.js</span>
<span class="keyword">var</span> fork = <span class="built_in">require</span>(<span class="string">"child_process"</span>).fork,
  cpus = <span class="built_in">require</span>(<span class="string">"os"</span>).cpus(),
  server = <span class="built_in">require</span>(<span class="string">"net"</span>).createServer()
  workers = {};

server.listen(<span class="number">1337</span>);

<span class="keyword">var</span> createWorker = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="keyword">var</span> worker = fork(<span class="string">"./test/worker.js"</span>);
  worker.send(<span class="string">"server"</span>, server);
  workers[worker.pid] = worker;
  <span class="built_in">console</span>.log(<span class="string">"create worker. pid: "</span> + worker.pid);

  worker.on(<span class="string">"exit"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="built_in">console</span>.log(<span class="string">"worker "</span> + worker.pid + <span class="string">" exited."</span>);
    <span class="keyword">delete</span> workers[worker.pid];
    createWorker();
  });
};

<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;cpus.length; i++) {
  createWorker();
}

process.on(<span class="string">"exit"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="keyword">for</span> (pid <span class="keyword">in</span> workers) {
    workers[pid].kill();
  }
});
</code></pre><p>The code above defined a createWorker function. Every worker that is created by this function will listen to its own exit event and create a new worker process once it exits. If the master process self exits, all workers will be killed.<br>The worker.js would look like this:</p>
<pre><code><span class="comment">//worker.js</span>
<span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);

<span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span><span class="params">(req,res)</span> </span>{
  res.writeHead(<span class="number">200</span>, {<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>});
  res.end(<span class="string">'handled by child, pid is '</span> + process.pid + <span class="string">'\n'</span>);
});

process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span><span class="params">(m, tcp)</span> </span>{
  <span class="keyword">if</span>(m === <span class="string">'server'</span>) {
    tcp.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span><span class="params">(socket)</span> </span>{
      server.emit(<span class="string">'connection'</span>, socket);
    });
  }
});
</code></pre><p>Run <code>node master.js</code> to create those process.</p>
<pre><code>&gt; node master.js
create worker. <span class="string">pid:</span> <span class="number">1089</span>
create worker. <span class="string">pid:</span> <span class="number">1090</span>
create worker. <span class="string">pid:</span> <span class="number">1091</span>
create worker. <span class="string">pid:</span> <span class="number">1092</span>
</code></pre><p>Now let’s kill a process to see what’s going on.</p>
<pre><code>&gt; <span class="built_in">kill</span> <span class="number">1089</span>
worker <span class="number">1089</span> exited.
<span class="built_in">create</span> worker. pid: <span class="number">1280</span>
</code></pre><p>Aha, one exits, one created.</p>
<p>Here we just killed a process manually. In most cases, there may be some undetected bugs caused unexpected exit. So it’d better to use uncaughtException event to listen uncaught error and do some synchronous cleanup before shutting down the process. Here, for test use, we just exit process to see how it works.</p>
<pre><code><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);

<span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span><span class="params">(req,res)</span> </span>{
  res.writeHead(<span class="number">200</span>, {<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>});
  res.end(<span class="string">'handled by child, pid is '</span> + process.pid + <span class="string">'\n'</span>);
  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"throw exception"</span>);
});

<span class="keyword">var</span> worker;
process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span><span class="params">(m, tcp)</span> </span>{
  <span class="keyword">if</span>(m === <span class="string">'server'</span>) {
    worker = tcp;
    tcp.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span><span class="params">(socket)</span> </span>{
      server.emit(<span class="string">'connection'</span>, socket);
    });
  }
});

process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span><span class="params">(err)</span> </span>{
  process.send({signal: <span class="string">'suicide'</span>}); <span class="comment">//send a suicide signal to master process</span>
  worker.close(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    process.exit();
  });
});
</code></pre><p>To simulate uncaught exception, we throw an error every time there is incomint request so that every time connect to the sever, a process will exit.</p>
<p>Note that we want the master process to recreate a process once error happened instead of waiting for worker process exits to ensure incoming request would be handled as much as possible. This could be done by creating worker in message event.</p>
<pre><code><span class="keyword">var</span> createWorker = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="keyword">var</span> worker = fork(<span class="string">"./test/worker.js"</span>);
  worker.send(<span class="string">"server"</span>, server);
  workers[worker.pid] = worker;
  <span class="built_in">console</span>.log(<span class="string">"create worker. pid: "</span> + worker.pid);

  worker.on(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span><span class="params">(message)</span> </span>{
  <span class="keyword">if</span>(message.signal === <span class="string">'suicide'</span>) {
      createWorker();
  }
  });

  worker.on(<span class="string">"exit"</span>, <span class="function"><span class="keyword">function</span><span class="params">(code, sign)</span> </span>{
  <span class="built_in">console</span>.log(<span class="string">"worker "</span> + worker.pid + <span class="string">" exited."</span>);
  <span class="keyword">delete</span> workers[worker.pid];
  });
};
</code></pre><h2 id="limit_restarts">limit restarts</h2><p>One more thing to do. If the error happens when creating the process, it is not in the case of uncaughtException. That would cause unlimit process restart. To avoid this unlimit restart, it’d better to limit the number of restarts during a period of time.</p>
<pre><code><span class="comment">//master.js</span>
<span class="keyword">var</span> fork = <span class="built_in">require</span>(<span class="string">"child_process"</span>).fork,
  cpus = <span class="built_in">require</span>(<span class="string">"os"</span>).cpus(),
  server = <span class="built_in">require</span>(<span class="string">"net"</span>).createServer()
  workers = {},
  limit = <span class="number">10</span>,<span class="comment">//restart limit</span>
  restart = [];

server.listen(<span class="number">1337</span>);

<span class="keyword">var</span> isTooFrequently = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="keyword">var</span> time = <span class="built_in">Date</span>.now();
  <span class="keyword">var</span> length = restart.push(time);
  <span class="keyword">if</span>(length &gt; limit) {
    restart = restart.slice(limit * -<span class="number">1</span>);
  }
  <span class="keyword">return</span> restart.length &gt;= limit &amp;&amp; restart[restart.length -<span class="number">1</span>] -restart[<span class="number">0</span>] &lt;during;
}

<span class="keyword">var</span> createWorker = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="keyword">if</span>(isTooFrequently()) {
    process.emit(<span class="string">'giveup'</span>, length, during);
    <span class="keyword">return</span>;
  }
  <span class="keyword">var</span> worker = fork(<span class="string">"worker.js"</span>);
  worker.send(<span class="string">"server"</span>, server);
  workers[worker.pid] = worker;
  <span class="built_in">console</span>.log(<span class="string">"create worker. pid: "</span> + worker.pid);

  worker.on(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span><span class="params">(message)</span> </span>{
    <span class="keyword">if</span>(message.signal === <span class="string">'suicide'</span>) {
      createWorker();
    }
  });

  worker.on(<span class="string">"exit"</span>, <span class="function"><span class="keyword">function</span><span class="params">(code, sign)</span> </span>{
    <span class="built_in">console</span>.log(<span class="string">"worker "</span> + worker.pid + <span class="string">" exited."</span>);
    <span class="keyword">delete</span> workers[worker.pid];
  });
};

<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; cpus.length; i++) {
  createWorker();
}

process.on(<span class="string">"exit"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="keyword">for</span> (pid <span class="keyword">in</span> workers) {
    workers[pid].kill();
  }
});
</code></pre><p>This isTooFrequently function does the judgement. It emits giveup event if restarts more than 10 times in a minute.</p>
<h2 id="reference">reference</h2><ul>
<li><a href="https://book.douban.com/subject/25768396/" target="_blank" rel="external">深入浅出nodejs</a></li>
<li><a href="https://nodejs.org/api/process.html#process_signal_events" target="_blank" rel="external">Node.js v4.1.1 Documentation</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>If you have been broken, mend yourself. Knowing that you will become more beautiful. And always think before you act. an apology cannot repair something you’ve done without thought.</p>
</blockquote>
<p>Last week we talked about multi process and process communication. Today we’re going to take a look at its stability.</p>
<p>Having multi processes work together can improve the usage of our cups at some extend. But how it stability is? What if the process exits unexpected?</p>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
      <category term="tech" scheme="http://yoursite.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[understanding node process(1)]]></title>
    <link href="http://yoursite.com/2015/09/19/understanding-node-process-1/"/>
    <id>http://yoursite.com/2015/09/19/understanding-node-process-1/</id>
    <published>2015-09-19T12:52:53.000Z</published>
    <updated>2015-09-19T13:13:21.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>And Lost be the day to us in Which a measure hath not been danced.</p>
<p>And false be every truth which hath not had laughter along with it.</p>
<p>— Niezsche</p>
</blockquote>
<p>As we know, javascript is running on a single process, which brings a question, how can we get the multi-core CPU fully work?</p>
<a id="more"></a>
<h2 id="Multi-process_structure">Multi-process structure</h2><p>Fortunately, node offers us child_process moudle so that we can easily create multi-porcess and work them together.</p>
<p>First of all, we create a js file named parent.js which will create a child process and listen to it.</p>
<pre><code><span class="comment">//parent.js</span>
<span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">'child_process'</span>),
    n = cp.fork(<span class="string">'test/child.js'</span>);

n.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span><span class="params">(m)</span> </span>{
  <span class="built_in">console</span>.log(<span class="string">'parent got message: '</span>, m);
});

n.send({hello: <span class="string">'world'</span>});
</code></pre><p>Note that <code>fork</code> creates a new process whice has all the mehods in a normal ChildProcess with a build-in communication channel(Inter-Process communication channel ). So we can write to a child using <code>send</code> method.</p>
<p>what the child process does is, as same as the parent process’s, listening to the parent process. When there is message come, they print the message out.</p>
<pre><code>process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span><span class="params">(m)</span> </span>{
  <span class="built_in">console</span>.log(<span class="string">'child got meaage: '</span>, m);
});
process.send({foo: <span class="string">'bar'</span>});
</code></pre><p>Running command  <code>node parent.js</code> we can get the following:</p>
<pre><code>child got <span class="string">meaage:</span>  { <span class="string">hello:</span> <span class="string">'world'</span> }
parent got <span class="string">message:</span>  { <span class="string">foo:</span> <span class="string">'bar'</span> }
</code></pre><p>Here we go, now we have two process runing and communicating.</p>
<h2 id="the_handler_delivery">the handler delivery</h2><p>Only text message sent is probably not enough. However, we can also send TCP server or socket object as handler to another process.</p>
<pre><code><span class="comment">//parent.js</span>
<span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">'child_process'</span>),
  child = cp.fork(<span class="string">'test/child.js'</span>);

<span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'net'</span>).createServer();
server.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span><span class="params">(socket)</span> </span>{
  socket.end(<span class="string">'handled by parent\n'</span>);
});

server.listen(<span class="number">1337</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  child.send(<span class="string">'server'</span>, server);
});
</code></pre><p>the child.js would look like this:</p>
<pre><code>process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span><span class="params">(m, server)</span></span> {
  <span class="keyword">if</span>(m === <span class="string">'server'</span>) {
    server.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span><span class="params">(socket)</span></span> {
      socket.<span class="keyword">end</span>(<span class="string">'handled by child\n'</span>);
    });
  }
});
</code></pre><p>Now the server is shared between the parent and child. That means connections can be handled by either of them. Running <code>node parent.js</code> and we test it by <code>curl &quot;http://localhost:1337/&quot;</code> the result can be both.</p>
<p>What if we seperate the tasks of parent process and child process? Once the handle is sent to child process from parent process, we close the server so it no longer listens to the port.</p>
<pre><code><span class="comment">//parent.js</span>
<span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">'child_process'</span>),
    child1 = cp.fork(<span class="string">'test/child.js'</span>),
    child2 = cp.fork(<span class="string">'test/child.js'</span>);

<span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'net'</span>).createServer();

server.listen(<span class="number">1337</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  child1.send(<span class="string">'server'</span>, server);
  child2.send(<span class="string">'server'</span>, server);
  server.close();
});

server.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
  <span class="built_in">console</span>.log(<span class="string">'server closed'</span>);
})
</code></pre><p>change child.js a litte:</p>
<pre><code><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);

<span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span><span class="params">(req,res)</span> </span>{
  res.writeHead(<span class="number">200</span>, {<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>});
  res.end(<span class="string">'handled by child, pid is '</span> + process.pid + <span class="string">'\n'</span>);
});

process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span><span class="params">(m, tcp)</span> </span>{
  <span class="keyword">if</span>(m === <span class="string">'server'</span>) {
    tcp.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span><span class="params">(socket)</span> </span>{
      server.emit(<span class="string">'connection'</span>, socket);
    });
  }
});
</code></pre><p>Now we have two child processes to listen to the port. Once TCP connection is emited, we emit http connection and send client socket object to http server to do something.</p>
<p>Notice that tcp server is shard by more than one child process, It’s possible that the request is handled by differnt child process. But it’s fine. The process  service is preemptive. Depends how busy the process is, the less busy one will handle the request.</p>
<p>Even if node is running on a single process, with multi-process running, we can still better using multi-core CPU and likely to handle high loads situation.</p>
<h3 id="Reference">Reference</h3><ul>
<li><a href="https://nodejs.org/api/child_process.html" target="_blank" rel="external">Node.js v4.1.0 Documentation</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>And Lost be the day to us in Which a measure hath not been danced.</p>
<p>And false be every truth which hath not had laughter along with it.</p>
<p>— Niezsche</p>
</blockquote>
<p>As we know, javascript is running on a single process, which brings a question, how can we get the multi-core CPU fully work?</p>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
      <category term="tech" scheme="http://yoursite.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅谈javascript执行作用域]]></title>
    <link href="http://yoursite.com/2015/08/24/%E6%B5%85%E8%B0%88javascript%E6%89%A7%E8%A1%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2015/08/24/浅谈javascript执行作用域/</id>
    <published>2015-08-24T13:24:25.000Z</published>
    <updated>2015-08-24T15:49:35.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>An old Cherokee told his grandson “my son, there is a battle between 2 wolves inside us all. One is Evil. It is anger, jealousy, greed, resentment, inferiority, lies and ego. The other is Good. It’s joy, kindness, empathy and truth”. The boy thought about it and asked “Gran, which wolf wins?”. The old man quietly replied “The one you feed”.</p>
</blockquote>
<p><br></p>
<p>最近看看javascript基础知识，今天来粗浅的谈谈javascript里函数作用域。</p>
<p>说到函数作用域，就不得不提到闭包。子函数任意访问父函数的变量，并对其长期持有。父函数外部不能访问内部变量。这就是闭包。<br><a id="more"></a></p>
<p>直接上代码：</p>
<pre><code><span class="keyword">var</span> globalVariable = <span class="number">1</span>;
(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="keyword">var</span> localVariable = <span class="number">1</span>;
  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    localVariable += globalVariable;
    <span class="built_in">console</span>.log(localVariable);
  }
})();

add(); <span class="comment">// 2</span>
</code></pre><p>上面的代码结构是这样的：</p>
<pre><code><span class="list">(<span class="keyword">function</span><span class="list">()</span> <span class="collection">{ /* logic goes here */ }</span>)</span><span class="list">()</span><span class="comment">;</span>
</code></pre><p>第一个括号内定义了一个匿名函数（以下叫做一次性匿名函数），第二个括号的作用是立即执行这个函数。上面代码中的this其实是指向外部环境。this上挂载了一个add属性。这个属性的值是一个函数字面量。也就是一次性匿名函数的内部函数。之前提到子函数可以访问父函数变量并长期持有。即使一次性匿名函数执行完后被回收掉，add()仍然是存在的（因为add方法是挂载在全局的）。由于add 长期持有localVariable的引用。我们就可以通过add() 访问localVariable，这就形成了闭包。</p>
<h3 id="实例：">实例：</h3><p>在实际项目里，我就遇到了一个由于变量作用域导致的问题。应用场景大概是这样的：<br>在一个地图上画一个多边形，我有一个对象数组，这个数组里是每一个对象代表地图上多边形的每个折点。现在需要给每一个折点添加dragend事件，鼠标拖动点到新的位置时，更新对象数组中相应点的经纬度位置。起初我是这么做的：(注：以下仅是一段伪代码)</p>
<pre><code>Points = [pt1, pt2, pt3, pt4, pt5]
<span class="comment">//foreach Points as tmpPt, i</span>
<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;Points.length; i++) {
  <span class="keyword">var</span> tmpPt = Points[i];
  tmpPt.addEventListener(<span class="string">'dragend'</span>, <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>{
      Points[i].latlng = e.lat + <span class="string">','</span> + e.lng;
  });
}
</code></pre><p>可是执行的时候，无论我改变哪一个点的位置，Points中点的经纬度都没有变化。这是因为当我给每个点注册了事件后，循环结束，i已经变成了Points.length。dragend触发后程序试图修改Points[Points.length]（其实这个对象根本就不存在）。</p>
<p>这里真正需要的是在回调函数执行时能够取得该点在数组中的索引值。那么就必须把每次循环里的i变成回调函数的内部参数，使其能够长期持有。我的做法是：</p>
<pre><code>tmpPt.addEventListener(<span class="string">'dragend'</span>, (<span class="function"><span class="keyword">function</span><span class="params">(index)</span>{</span>
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(e)</span> {</span>
        Points<span class="matrix">[index]</span>.latlng = e.lat + <span class="string">','</span> + e.lng;
    }
})(<span class="built_in">i</span>)
);
</code></pre><p>注册dragend事件是会立即执行这个一次性匿名函数，把每次循环里的i作为参数传递给一次性执行函数，最后返回一个function (这个返回的function就是回调函数)。此时的i就是一次性匿名函数的内部参数。这里形成了闭包。无论鼠标拖动哪个点，都能够在回调函数中得到正确的索引值。</p>
<p>tips: 学习过程中顺便了解到了函数定义方法 var a = function(){} 和 function a(){} 的区别。 两个函数的调用和功能实现都是一致的。只是function语句（即后者）在解析时会发生被提升的情况。也就是说无论function被放置在哪里，都会被移动到所在作用域的顶层。</p>
<pre><code><span class="built_in">console</span>.log(getA); <span class="comment">// 输出结果： function getA()</span>
<span class="function"><span class="keyword">function</span> <span class="title">getA</span><span class="params">()</span></span>{
    <span class="keyword">return</span> <span class="string">'a'</span>;
}

<span class="built_in">console</span>.log(getB); <span class="comment">// 输出结果： undefined</span>
<span class="keyword">var</span> getB = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">return</span> <span class="string">'B'</span>;
}
</code></pre><p>function getA(){…}在解析时就会被提到作用域顶层。 但是为了不导致混乱，还是建议大家在写代码是先定义再调用。</p>
<h3 id="参考资料">参考资料</h3><ul>
<li><a href="http://blog.csdn.net/pusongyang/article/details/7034904" target="_blank" rel="external">再谈Javascript中function fn(){}和var fn=function(){}</a></li>
<li>javascript语言精粹</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>An old Cherokee told his grandson “my son, there is a battle between 2 wolves inside us all. One is Evil. It is anger, jealousy, greed, resentment, inferiority, lies and ego. The other is Good. It’s joy, kindness, empathy and truth”. The boy thought about it and asked “Gran, which wolf wins?”. The old man quietly replied “The one you feed”.</p>
</blockquote>
<p><br></p>
<p>最近看看javascript基础知识，今天来粗浅的谈谈javascript里函数作用域。</p>
<p>说到函数作用域，就不得不提到闭包。子函数任意访问父函数的变量，并对其长期持有。父函数外部不能访问内部变量。这就是闭包。<br>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="tech" scheme="http://yoursite.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[What we lost?]]></title>
    <link href="http://yoursite.com/2015/08/13/What-we-lost/"/>
    <id>http://yoursite.com/2015/08/13/What-we-lost/</id>
    <published>2015-08-13T14:24:56.000Z</published>
    <updated>2015-08-13T14:31:32.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>In the age of acceleration, nothing can be more exhilarating than going slow. And in the age of distraction, nothing is so luxurious as paying attention. And in the age of constant movement, nothing is so urgent as sitting still.</p>
</blockquote>
<p>Technologe brings our life into a new stage of century. Everything is rising faster and faster. And it means to be used by saving time. But why we still feel lack of time, even more than before? What we lost when we are all rushing into the entire new age?</p>
<a id="more"></a>
<p>In this complete fast going world, we work longer, spending more time on social network instead of being with friends and family in real life. I can’t belive technology is actually cutting off the connection between people. It’s hard to feel the surroundings with all your heart. And certainly, most of us, including me, read people’s life through something called Internet, something called fackbook, wechat comment and other social apps. It, however, is huge waste of time. Because I don’t need to read people’s life but join it.</p>
<p>This is not the first time I feel that my life is going faster than I can be with. We all do. Since last year, while I was rushing into the future, all I heard in my head is noisy, the noisy from outside world. I was the most anxious,emotional painful than I ever felt, which brought me to the hell. I was crying a few times a day. without any reason. Everything that is happening can be the trigger to make me cry. My life was such a mess. I lost the inner peace. I lost the balance between inside and outside. There was nothing I can do to save my life until I went maditating again. What I found out is that the more I was emotional uncomfortable, the more concentrated I can be.</p>
<p>Maditating is slowing me down and preventing me from rushing into the furture. Technologe dose excellent work by improving work efficiency if it’s used correctly. However, it also bring us the side effects of life. What technologe hasn’t always given us is a sense of how to wisest use of technology. In return, it perhaps makes you more tired, confused instead.</p>
<p>This world is much more powerful, infomative. We all go too fast and want to take advantage of it. But on the other hand, it costs more on real personal life.  It’s hard to keep peace inside, that’s also exactly what outside world make us suffer by. Maybe the only way to keep ourselves, our sprits, survive from it is slowing down, feeling things around you with all your heart. The smile of people, the sounds of laughing, the sensation of touching things, and the feeling when you hug people etc.</p>
<p>Meditation ,for me, is not only about sitting down. When you do something with 100% concentration. You are being the present, you are meditating. It’s hard to explain how it changed me. And I’m still trying. But it works. It works well.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>In the age of acceleration, nothing can be more exhilarating than going slow. And in the age of distraction, nothing is so luxurious as paying attention. And in the age of constant movement, nothing is so urgent as sitting still.</p>
</blockquote>
<p>Technologe brings our life into a new stage of century. Everything is rising faster and faster. And it means to be used by saving time. But why we still feel lack of time, even more than before? What we lost when we are all rushing into the entire new age?</p>]]>
    
    </summary>
    
      <category term="life" scheme="http://yoursite.com/tags/life/"/>
    
      <category term="meditation" scheme="http://yoursite.com/tags/meditation/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[gulp学习初体验]]></title>
    <link href="http://yoursite.com/2015/06/21/gulp%E5%AD%A6%E4%B9%A0%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://yoursite.com/2015/06/21/gulp学习初体验/</id>
    <published>2015-06-21T13:02:53.000Z</published>
    <updated>2015-06-21T16:05:37.000Z</updated>
    <content type="html"><![CDATA[<p>花了一天的时间，把gulp的一些基本用法过了一遍。总算对其有了些了解。记录下学习中的不解，也算对这次的学习一个总结。</p>
<p>首先介绍一下gulp，gulp是一个前端构建工具，利用它可以在项目开发过程中自动化执行任务。有赖于其强大的插件系统，我们可以利用gulp完成很多任务，例如执行JSHint，编译stylus，更新版本号等。</p>
<a id="more"></a>
<h2 id="安装gulp：">安装gulp：</h2><p>全局安装：</p>
<pre><code>npm <span class="keyword">install</span> -g gulp
</code></pre><p>项目安装：</p>
<pre><code>npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> gulp
</code></pre><p>—save-dev 安装包将在开发环境下安装，版本信息写入package.json的devDependencies下。</p>
<p>gulp任务都定义在gulpfile.js中，可以在终端运行gulp命令来执行。</p>
<h2 id="gulp任务">gulp任务</h2><p>加载gulp模块</p>
<pre><code><span class="reserved">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);
</code></pre><p>其他gulp插件的加载也是一样。</p>
<p>下面是一段编译stylus的gulp task代码，用来简单解释一下gulp的工作流程。</p>
<pre><code>gulp.task(<span class="string">'stylus'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
  gulp.src(<span class="string">'./assets/stylus/style.styl'</span>)
      .pipe(stylus())
      .pipe(gulp.dest(<span class="string">'./assets/stylesheets'</span>));
});
</code></pre><p>gulp.task(taskName, excutor)用来定义任务。需要任务名和执行函数两个参数。执行函数也可以是多个任务。</p>
<p>gulp.task(‘build’, [‘task’, ‘anotherTask’]);</p>
<p>但是这些任务不是顺序执行的。要保证一个任务先于另一个执行可以：</p>
<pre><code>gulp.task(<span class="string">'taskTwo'</span>, [<span class="string">'taskOne'</span>], <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
   <span class="comment">// taskTwo</span>
});
</code></pre><p>taskTwo 会在 taskOne执行完后再执行。</p>
<p>gulp.src()函数用来匹配文件，创建一个对象流来代表这些文件，之后的操作都是以这些文件为对象进行操作。pipe顾名思义就是管道的意思， stylus()返回修改后的文件对象放入流中，这些输出的文件随着管道被输入到gulp.dest()函数中并保持下来。</p>
<p>最后不要忘记在文件头部加载gulp-stylus模块。</p>
<h2 id="运行gulp">运行gulp</h2><p>终端执行 <code>$ gulp</code> 会报错，因为gulp默认会执行default 任务。需要在gulpfile.js内定义此任务</p>
<pre><code>gulp.task(<span class="string">'default'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
  <span class="comment">//deal with default task</span>
})
</code></pre><p>如果要运行指定任务</p>
<pre><code><span class="variable">$ </span>gulp taskName
</code></pre><h2 id="watching_files">watching files</h2><p>用gulp来监听文件的修改状态非常方便。我们来定义一个watch任务看一下</p>
<pre><code>gulp.task(<span class="string">'watch'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
  gulp.watch(<span class="string">'./assets/stylus/*.styl'</span>, [<span class="string">'stylus'</span>]);
});
</code></pre><p>现在当改变styl文件时就会执行stylus任务。</p>
<p>当然仅仅是watch是不够的，我们还希望在文件修改的同时浏览器能同步更新。browserSync插件就可以做到。当改变代码的时候，BrowserSync会重新加载页面，如果是css文件，会直接添加进css中，页面并不需要再次刷新。这样我们修改前端代码时就不需要每次都手动刷新浏览器。</p>
<pre><code><span class="tag">gulp</span><span class="class">.task</span>(<span class="string">'browser-sync'</span>, <span class="function">function</span>(){
  <span class="tag">browserSync</span><span class="class">.init</span>(null, {
    <span class="attribute">proxy</span>: <span class="string">'http://localhost:3000'</span>,
    <span class="attribute">files</span>: [<span class="string">'assets/stylesheets/*.css'</span>],
    <span class="attribute">browser</span>: <span class="string">'google-chrome'</span>,
    <span class="attribute">port</span>: <span class="number">7000</span>,
    <span class="attribute">reloadOnRestart</span>: false
  });
});
<span class="tag">gulp</span><span class="class">.task</span>(<span class="string">'default'</span>, [<span class="string">'browser-sync'</span>]);
</code></pre><p>gulp运行时会默认执行browser-sync任务。启动browserSync，监听css文件的改变并在chrome中加载更新的部分。</p>
<blockquote>
<p> proxy: vhost url<br> files: 监听改变的文件<br> port: browser侦测改变的端口</p>
</blockquote>
<p>browserSync主要监听浏览器端的改变，要监听更新服务端需要用到nodemon</p>
<pre><code>gulp.task(<span class="string">'nodemon'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
  <span class="keyword">return</span> nodemon({
    script: <span class="string">'bin/www'</span>,
    ext: <span class="string">'js'</span>
  }).on(<span class="string">'start'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{

  });
});
</code></pre><p>项目开发是基于express， 这段代码会执行bin/www文件运行服务端，并监听js文件的改变，每次改变重启服务。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>花了一天的时间，把gulp的一些基本用法过了一遍。总算对其有了些了解。记录下学习中的不解，也算对这次的学习一个总结。</p>
<p>首先介绍一下gulp，gulp是一个前端构建工具，利用它可以在项目开发过程中自动化执行任务。有赖于其强大的插件系统，我们可以利用gulp完成很多任务，例如执行JSHint，编译stylus，更新版本号等。</p>]]>
    
    </summary>
    
      <category term="front-end" scheme="http://yoursite.com/tags/front-end/"/>
    
      <category term="tech" scheme="http://yoursite.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[双线部署遇到的问题]]></title>
    <link href="http://yoursite.com/2015/05/03/%E5%8F%8C%E7%BA%BF%E9%83%A8%E7%BD%B2%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2015/05/03/双线部署遇到的问题/</id>
    <published>2015-05-03T07:23:20.000Z</published>
    <updated>2015-05-09T15:35:26.000Z</updated>
    <content type="html"><![CDATA[<p>本来博客是放在github上面，但是由于国内网络环境（大家懂的），github访问不是很稳定，随时被查水表。所以采取网友的建议，在gitcafe也部署一个。gifcafe是国内的，速度杠杠的～</p>
<a id="more"></a>
<p>这样国内访问走gitcafe，国外访问走github，再做个dnspod双线解析就大功告成。</p>
<p>下面纪录重新双线部署过程中遇到的问题，作学习之用。</p>
<p>hexo部署单个平台没有问题，但是添加一个gitcafe，再deploy就报错了。</p>
<blockquote>
<p>deploy:<br>- type: git<br>  repository: github url<br>  branch: master<br>- type: git<br>  repository: gitcafe url<br>  branch: gitcafe-pages</p>
</blockquote>
<p>github可以正常deploy，gitcafe报错：permission denied。 我想应该是生成的ssh key出了问题。</p>
<p>这里简单说一下ssh key， 为了避免没错连接到github或gitcafe都要输入密码，可以用邮件地址在本地生成id_rsa 和 id_rsa.pub，前者是私钥自己保存，后者是公钥需要添加到github和gitcafe，这样就不用每次连接都输入密码做身份验证了。关于ssh key的生成请戳<a href="https://help.github.com/articles/generating-ssh-keys/" target="_blank" rel="external">这里</a>。</p>
<p>我之前是针对github和gitcafe分别生成了id_rsa,id_rsa.pub和cafe_rsa和cafe_rsa.pub。</p>
<p>但是问题来了，这么多私钥ssh不知道应该用哪一个。其实~/.ssh/id_rsa是基本私钥，ssh总是把它当作提交私钥的首选项。但是如果存在其他的私钥，就需要向ssh提及，好像登记样，并且配置~/.ssh下config文件来指定不同host应该使用的私钥文件。具体看下面：</p>
<pre><code>ssh-<span class="keyword">add</span> ~/.ssh/cafe_rsa
</code></pre><p>检查是否添加成功：</p>
<pre><code>ssh-<span class="keyword">add</span> -l
</code></pre><p>如果是这样就成功了：</p>
<blockquote>
<p>2048 dc:0f:0d:5b:…:a0:0b:a7:d3:62:a6:bc:bc /Users/username/.ssh/id_rsa (RSA)<br>2048 d8:2c:1c:25:…:56:14:c7:79:7e:20:43:20 /Users/username/.ssh/cafe_rsa (RSA)</p>
</blockquote>
<p>config文件的配置：</p>
<blockquote>
<p>Host username.github.com<br>HostName github.com<br>User git<br>IdentityFile ~/.ssh/id_rsa</p>
<p>Host username.gitcafe.com<br>HostName gitcafe.com<br>User git<br>IdentityFile ~/.ssh/cafe_rsa</p>
</blockquote>
<p>同理，如果是一个平台有多个用户，只需要添加相同的项并修改Host的username就行了～</p>
<p>但是我想同时生成那么多key也不是很方便，所以取消了cafe_rsa,直接把id_rsa.pub作为github和gitcafe的ssh key。这样两个平台就公用一个本地私钥。也不用再去设置什么config文件。需要注意的是，生成密钥的邮箱和我github，gitcafe的邮箱是一样的。</p>
<p>再修改一下hexo的_config.yml文件：</p>
<blockquote>
<p>deploy:<br> type: git<br> repository:<br>   github: git@username.github.com:username/username.github.io.git,[branch]<br>   gitcafe: git@username.gitcafe.com:username/username.git,[branch]</p>
</blockquote>
<p>这下就可以同时对两个平台进行部署，尽情发布了～</p>
<h6 id="参考资料">参考资料</h6><ul>
<li><a href="http://wshuyi.github.io/2014/08/22/hexoGithubGitCafe20140822/" target="_blank" rel="external">在github和gitcafe上同时部署hexo博客</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>本来博客是放在github上面，但是由于国内网络环境（大家懂的），github访问不是很稳定，随时被查水表。所以采取网友的建议，在gitcafe也部署一个。gifcafe是国内的，速度杠杠的～</p>]]>
    
    </summary>
    
      <category term="issue" scheme="http://yoursite.com/tags/issue/"/>
    
      <category term="tech" scheme="http://yoursite.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[setup Macbook]]></title>
    <link href="http://yoursite.com/2015/05/02/setup-Macbook/"/>
    <id>http://yoursite.com/2015/05/02/setup-Macbook/</id>
    <published>2015-05-02T15:35:56.000Z</published>
    <updated>2015-05-03T09:11:04.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>工欲善其事，必先利其器</p>
</blockquote>
<p>折腾了两天，终于把新到手的Macbook 各种配置好！ 中间遇到的问题不是一般两般的多，谁叫我是新手呢！！！</p>
<a id="more"></a>
<h2 id="开发">开发</h2><p>最开始的开始，当然是xcode了，很多安装都需要xcode ready first。</p>
<ul>
<li><p>Homebrew： 很好用的包管理工具，后期安装一些应用、插件之类的很方便。</p>
</li>
<li><p>Iterm2 \＋ zsh: 我的最爱，强大的终端。<br><img src="https://iterm2.com/img/screenshots/split_panes_full.png" alt="Iterm2"><br>新手看起来瞬间高大上有木有～</p>
</li>
<li><p>Git： 她的美不言而喻。</p>
</li>
<li><p>Node.js： 有好多东西要学，先抓node。</p>
</li>
<li><p>NPM： Node的包管理系统，安装很方便～</p>
<ul>
<li><p>gulp： npm安装包。</p>
</li>
<li><p>bower： 另一个包管理工具，不要问我为什么那么多包管理工具～</p>
</li>
</ul>
</li>
</ul>
<h2 id="设计">设计</h2><p>Mac怎么能没有设计软件来配成。</p>
<ul>
<li><p>Adobe Photoshop CC</p>
</li>
<li><p>Adobe Lightroom (optional)</p>
</li>
<li><p>Adobe Illustrator (optional)</p>
</li>
<li><p>Sketch (optional)</p>
</li>
</ul>
<h2 id="网络">网络</h2><p>最后当然少不了穿越，你们懂得～</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>工欲善其事，必先利其器</p>
</blockquote>
<p>折腾了两天，终于把新到手的Macbook 各种配置好！ 中间遇到的问题不是一般两般的多，谁叫我是新手呢！！！</p>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://yoursite.com/tags/Mac/"/>
    
      <category term="front-end" scheme="http://yoursite.com/tags/front-end/"/>
    
  </entry>
  
</feed>